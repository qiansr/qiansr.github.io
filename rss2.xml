<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>神刀</title>
    <link>http://qiansr.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 18 Nov 2019 21:35:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Hello World</title>
      <link>http://qiansr.github.io/2019/11/19/hello-world/</link>
      <guid>http://qiansr.github.io/2019/11/19/hello-world/</guid>
      <pubDate>Mon, 18 Nov 2019 21:35:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Swig语法&quot;&gt;&lt;a href=&quot;#Swig语法&quot; class=&quot;headerlink&quot; title=&quot;Swig语法&quot;&gt;&lt;/a&gt;Swig语法&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;Every interaction is both precious and an 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Swig语法"><a href="#Swig语法" class="headerlink" title="Swig语法"></a>Swig语法</h2><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><blockquote><p>Every interaction is both precious and an opportunity to delight.<br>代码块</p></blockquote><h2 id="Swig语法-1"><a href="#Swig语法-1" class="headerlink" title="Swig语法"></a>Swig语法</h2><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><h2 id="Markdown语法-1"><a href="#Markdown语法-1" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><p>链接</p><a href="http://blog.fens.me" title="粉丝日志" target="_blank">粉丝日志</a><h2 id="Markdown语法-2"><a href="#Markdown语法-2" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><p><a href="http://blog.fens.me" target="_blank" rel="noopener">粉丝日志</a><br>图片，对于本地图片，需要在source目录下面新建一个目录images，然后把图片放到目录中。</p><h2 id="Swig语法-2"><a href="#Swig语法-2" class="headerlink" title="Swig语法"></a>Swig语法</h2><img src="/images/fens.me.png" width="400" height="600" title="这是一张图片"><h1 id="Markdown语法-3"><a href="#Markdown语法-3" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><img src="/images/fens.me.png" alt="这是一张图片"></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$J_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$</p><hr><p><br><br><br></p><h1 id="完整的Swig语法"><a href="#完整的Swig语法" class="headerlink" title="完整的Swig语法"></a>完整的Swig语法</h1><p>通过下面的命令，就可以创建新文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\workspace\javascript\nodejs-hexo&gt;hexo new 新的开始</span><br><span class="line">[info] File created at D:\workspace\javascript\nodejs-hexo\source\_posts\新的开始.md</span><br></pre></td></tr></table></figure></p><p>感觉非常好。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><a href="http://blog.fens.me" title="粉丝日志" target="_blank">粉丝日志</a><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><img src="/images/fens.me.png" width="400" height="600" title="这是一张图片">]]></content:encoded>
      
      <comments>http://qiansr.github.io/2019/11/19/hello-world/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深入理解js系列一作用域是什么？</title>
      <link>http://qiansr.github.io/2018/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</link>
      <guid>http://qiansr.github.io/2018/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</guid>
      <pubDate>Mon, 05 Feb 2018 18:15:59 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;作用域是什么？&quot;&gt;&lt;a href=&quot;#作用域是什么？&quot; class=&quot;headerlink&quot; title=&quot;作用域是什么？&quot;&gt;&lt;/a&gt;作用域是什么？&lt;/h1&gt;&lt;h1 id=&quot;变量的作用域到底是如何在js中工作的？&quot;&gt;&lt;a href=&quot;#变量的作用域到底是如何在js
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="作用域是什么？"><a href="#作用域是什么？" class="headerlink" title="作用域是什么？"></a>作用域是什么？</h1><h1 id="变量的作用域到底是如何在js中工作的？"><a href="#变量的作用域到底是如何在js中工作的？" class="headerlink" title="变量的作用域到底是如何在js中工作的？"></a>变量的作用域到底是如何在js中工作的？</h1><h1 id="js是解释型语言而无法编译吗？"><a href="#js是解释型语言而无法编译吗？" class="headerlink" title="js是解释型语言而无法编译吗？"></a>js是解释型语言而无法编译吗？</h1><h1 id="什么是词法作用域？"><a href="#什么是词法作用域？" class="headerlink" title="什么是词法作用域？"></a>什么是词法作用域？</h1><h1 id="RHS查询与LHS查询？"><a href="#RHS查询与LHS查询？" class="headerlink" title="RHS查询与LHS查询？"></a>RHS查询与LHS查询？</h1><h1 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h1><p>js中的作用域可以理解为一套定义的规则，用来管理js引擎根据标识符名称进行变量查找，并确定当前执行代码对这些变量的访问权限。  </p><h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>要想深入理解js的作用域，我们必须得先知道js事实上是一门编译型语言（动态编译）– js引擎实际上是动态编译程序然后立即执行。与传统编译语言在构建前编译不同的是：js的编译发生在代码执行前（有时是执行中）的很短时间内，而且编译完通常就会马上执行它。另外，对比传统编译，js引擎在语法分析和代码生成阶段有特定的步骤对运行性能进行优化。这也是后面会谈到的<code>eval()</code>和<code>with()</code> 影响运行效率的原因。</p><h1 id="编译的三个步骤"><a href="#编译的三个步骤" class="headerlink" title="编译的三个步骤"></a>编译的三个步骤</h1><p>我们先来看看在传统编译语言中，一段源程序在执行前通常要经历的三个步骤，js作为一门动态编译语言，同样也会经历这些步骤：</p><ol><li>分词／词法分析（将源代码分解成词法单元）</li><li>解析／语法解析（转换为一棵由元素逐级嵌套组成代表程序语法的抽象语法树AST）</li><li>代码生成（将AST转换为可执行代码）</li></ol><p>在js中，js引擎负责整个js程序的编译和执行过程，编译器负责语法分析以及代码生成。</p><h1 id="js引擎做了什么？"><a href="#js引擎做了什么？" class="headerlink" title="js引擎做了什么？"></a>js引擎做了什么？</h1><p>当遇到<code>var a = 2</code>这段程序，js引擎做了什么？</p><ol><li>首先编译器会将这段代码分解成词法单元</li><li>编译器再将词法单元解析成一个树结构</li><li>编译器开始进行代码生成  <ol><li>遇到<code>var a</code>，查询作用域链是否有变量a：<br> 。 有a：跳过继续编译<br> 。 无a：在当前作用域声明一个变量a</li><li>为引擎生成运行时所需代码    </li></ol></li><li>引擎查询作用域链是否存在变量a：<br> 。存在：使用变量a执行赋值操作<br> 。不存在：抛出一个异常</li></ol><p>可以看出，变量的赋值操作会执行两个动作：<br>一个由编译器在编译时处理，另一个由引擎在运行时处理。  </p><h1 id="RHS查询与LHS查询？-1"><a href="#RHS查询与LHS查询？-1" class="headerlink" title="RHS查询与LHS查询？"></a>RHS查询与LHS查询？</h1><p>LHS查询：查找变量的容器本身（a=1）<br>RHS查询： 查找变量的值（console.log(a)）</p><pre><code>function foo(a){    console.log(a)}foo(2) //RHS查询// 将2作为参数传给foo函数，给参数a隐式地分配值时进行了一次LHS查询</code></pre><h1 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在作用域中找不到变量  </p><p>在作用域中找变量  </p><p>总结：<br>不成功的RHS引用抛ReferenceError</p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2018/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo + github 博客搭建指南</title>
      <link>http://qiansr.github.io/2018/01/14/Hexo%20+%20github%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</link>
      <guid>http://qiansr.github.io/2018/01/14/Hexo%20+%20github%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Sat, 13 Jan 2018 18:18:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;用hexo-github-搭建博客&quot;&gt;&lt;a href=&quot;#用hexo-github-搭建博客&quot; class=&quot;headerlink&quot; title=&quot;用hexo + github 搭建博客&quot;&gt;&lt;/a&gt;用hexo + github 搭建博客&lt;/h1&gt;&lt;p&gt;早在几年以前
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="用hexo-github-搭建博客"><a href="#用hexo-github-搭建博客" class="headerlink" title="用hexo + github 搭建博客"></a>用hexo + github 搭建博客</h1><p>早在几年以前用hexo 搭建过一个博客系统部署到github上，但是一直没有用起来，平时都是习惯用mac 的备忘录记录一些东西。现在离职状态中准备找下个东家了，发现没个博客还是有些不妥，所以开始重新又弄了弄hexo，顺便也记录一下过程。</p><h2 id="新建github仓库"><a href="#新建github仓库" class="headerlink" title="新建github仓库"></a>新建github仓库</h2><p>仓库命名要同github账户名关连，格式如下:<br>仓库名：<code>qiansr.github.io</code><br>其中qiansr是我的github账户名，qiansr.github.io这个仓库名也将是你项目的访问域名。注意“<code>.github.io</code>” 不能省略。</p><h2 id="ssh密钥创建"><a href="#ssh密钥创建" class="headerlink" title="ssh密钥创建"></a>ssh密钥创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ～／.ssh</span><br><span class="line">ls -al ~/.ssh                                  //检查是否存在.pub</span><br><span class="line">ssh-keygen -t rss -C “youremail@email.com”    //创建钥匙对</span><br><span class="line">3. pbcopy &lt; id_rsa.pub                       //拷贝公钥到剪切板:</span><br><span class="line">4. 添加到gitlab或github账户</span><br></pre></td></tr></table></figure><h2 id="添加密钥"><a href="#添加密钥" class="headerlink" title="添加密钥"></a>添加密钥</h2><p>进入仓库=&gt;Settings=&gt;Deploy keys<br>Title:blog<br>Key:粘贴密钥<br>=&gt; add key</p><p><strong>测试添加ssh是否成功：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">==&gt; 如果看到下面这句：Hi后面是你的用户名，就说明成功了</span><br><span class="line">Hi qiansr! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ～</span><br><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><p>创建项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd ./blog</span><br><span class="line"></span><br><span class="line">vim package.json</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>修改package.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;3.4.4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.2.0&quot;,</span><br><span class="line">    &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">    &quot;hexo-generator-feed&quot;: &quot;^1.2.2&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-generator-sitemap&quot;: &quot;^1.2.0&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.2.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ESC + :wq           //保存退出vim</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>本地运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">==&gt;</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>在游览器中输入 <a href="http://localhost:4000/就可以看到你的博客了。" target="_blank" rel="noopener">http://localhost:4000/就可以看到你的博客了。</a></p><h2 id="配置hexo与github连接"><a href="#配置hexo与github连接" class="headerlink" title="配置hexo与github连接"></a>配置hexo与github连接</h2><p>打开_config.yml文件<br>修改deploy值，在最后一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/qiansr/qiansr.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>把qiansr替换成你的github用户名</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h2 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot;         #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot;    #新建页面</span><br><span class="line">hexo generate               #生成静态页面至public目录</span><br><span class="line">hexo server                 #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy                 #将.deploy目录部署到GitHub</span><br><span class="line">hexo help                   #查看帮助</span><br><span class="line">hexo version                #查看Hexo的版本</span><br></pre></td></tr></table></figure><h2 id="主题资源"><a href="#主题资源" class="headerlink" title="主题资源"></a>主题资源</h2><p><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">https://www.zhihu.com/question/24422335</a></p><h1 id="hexo-完善博客设置"><a href="#hexo-完善博客设置" class="headerlink" title="hexo 完善博客设置"></a>hexo 完善博客设置</h1><h3 id="Hexo博客绑定域名"><a href="#Hexo博客绑定域名" class="headerlink" title="Hexo博客绑定域名"></a>Hexo博客绑定域名</h3><p>参阅《hexo搭建的Github博客绑定域名》：<a href="http://www.jianshu.com/p/cea41e5c9b2a" target="_blank" rel="noopener">http://www.jianshu.com/p/cea41e5c9b2a</a></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line">cd 根目录</span><br><span class="line">vim _config.yml</span><br><span class="line">找到theme属性，将其由landscape（默认主题）改为next。</span><br></pre></td></tr></table></figure><h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><p>这里我选用的是NexT主题<br>在NexT主题目录下同样有一个名为_config.yml文件，称为主题配置文件，在其中找到scheme属性，<br>NexT主题默认使用Muse模式，你可根据自己的喜好，选择其中一种模式。</p><h3 id="预览摘要"><a href="#预览摘要" class="headerlink" title="预览摘要"></a>预览摘要</h3><p>主题配置文件 auto_excerpt 属性：<br>enable: true<br>length: 150 #想要预览到的字数<br>￼</p><h3 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h3><p>目前多说以挂，所以我们这里添加的是友言的评论系统<br>注册友言账号，获取uid  （后台管理 =&gt; 用户ID）<br>打开主题配置文件 找到youyan_uid属性设置uid  </p><h2 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">微信收款二维码     教程: https://jingyan.baidu.com/article/b907e627b641b646e6891c6b.html  </span><br><span class="line">支付宝收款二维码    教程: http://blog.csdn.net/china8848/article/details/53504223  </span><br><span class="line"></span><br><span class="line">二维码图片放到NexT根目录`/source/images/`文件夹下  </span><br><span class="line">开启打赏功能主题配置文件，在其最后添加打赏的配置信息:</span><br><span class="line"></span><br><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！  </span><br><span class="line">wechatpay: 图片链接或图片相对路径  </span><br><span class="line">alipay: 图片链接或图片相对路径</span><br></pre></td></tr></table></figure><h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><p>主题配置文件 sidebar的display属性，display属性有四种显示模式：<br>post    // 默认显示方式<br>always  // 一直显示<br>hide    // 初始隐藏<br>remove  // 移除侧边栏</p><h3 id="添加菜单选项（菜单栏标签页）"><a href="#添加菜单选项（菜单栏标签页）" class="headerlink" title="添加菜单选项（菜单栏标签页）"></a>添加菜单选项（菜单栏标签页）</h3><p>默认菜单只有首页、归档、关于三个选项，主题配置文件找到menu属性，通过去掉categories、 tags、about的的注释新增标签页：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 命令行执行下列命令来添加分类页面</span><br><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page “tags”</span><br><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure><p>会在source 目录下创建的三个目录和各自的index.md文件<br>打开index.md中在头部分别添加  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: “categories”</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure><p>当要为某一篇文章添加标签，在tags中添加，添加分类在categories中添加。</p><h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><p>搜索的功能源于第三方服务——Algolia，接下来看看配置的步骤：注册Algolia官网，创建一个Index。<br>安装Hexo Algolia</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-algolia</span><br></pre></td></tr></table></figure><p>如果安装失败，找到package.json文件，修改其中的hexo-algolia属性值为^0.2.0，然后再重新安装<br>获取Key，修改站点配置Algolia官网的Dashboard =&gt; API Keys<br>编辑站点配置文件，在文件内容最后添加如下信息，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ApplicationID: ‘’</span><br><span class="line">Search-Only API Key: </span><br><span class="line">Admin API Key: </span><br><span class="line">indexName: </span><br><span class="line">#其中apiKey就是Search-Only API Key：</span><br></pre></td></tr></table></figure><p>更新Index配置好Key后，在Hexo根目录执行hexo algolia来更新Index<br>启用配置搜索功能修改主题配置文件，在其中找到algolia_search属性，将其enable子属性改为true，然后再看其labels子属性，修改相应的提示文本，使之更加适合自己的风格  </p><div color:red="">（本人博客配置完了，发现搜索不到任何内容，目前不想再捣鼓了，有人遇到类似问题如果解决了麻烦贴一下解决办法）</div><h3 id="阅读次数"><a href="#阅读次数" class="headerlink" title="阅读次数"></a>阅读次数</h3><p>阅读次数统计是基于第三方服务——LeanCloud实现的，其配置详情如下：<br>创建LeanCloud账号进入LeanCloud官网完成注册:创建应用选择开发版 =&gt; 存储 =&gt;<br>创建Class名称为Counter =&gt; 选择无限制选项<br>配置Key:单击应用Key，可以看到应用的App ID和App Key。主题配置文件中，在文件中找到leancloud_visitors属性，将enable设置为true，然后将之前复制的ID和Key粘贴到相应的属性中。</p><h3 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h3><p>在主题配置文件中找到<code>social</code>属性，在其下方添加社交链接，其格式为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github：链接</span><br></pre></td></tr></table></figure><p><strong>添加链接图标</strong>  </p><p>主题配置文件中找到<code>social_icons</code>，修改其状态值为true，然后配置对应链接的图标，其格式为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github: Font Awesome中的图标的名字（区分大小写）</span><br><span class="line">Font Awesome平台没有的图标，会显示默认。</span><br></pre></td></tr></table></figure><p><strong>友情链接</strong><br>主题配置文件中找到links属性，修改<code>links_title</code>属性的值为“友情链接”，然后添加上好友的友链名称和地址，其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名称: 链接</span><br></pre></td></tr></table></figure><h3 id="语言设定"><a href="#语言设定" class="headerlink" title="语言设定"></a>语言设定</h3><p>在站点根目录下修改配置文件_cofig.yml中的language为zh-Hans（简体中文）</p><h3 id="增改菜选项"><a href="#增改菜选项" class="headerlink" title="增改菜选项"></a>增改菜选项</h3><p>修改在主题目录下配置文件_cofig.yml中的menu，增添一个something<br>修改主题目录下的languages文件中对应的zh-hans.yml文档<br>设置菜单项图标，对应的字段是menu_icons。格式为item name：icon name，其中item name与所配置的菜单名字对应，icon name是Font Awesome图标的名字。</p><h3 id="设置侧栏位置"><a href="#设置侧栏位置" class="headerlink" title="设置侧栏位置"></a>设置侧栏位置</h3><p>修改主题目录下sidebar的position值</p><h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下）</p><h3 id="设置文章代码主题"><a href="#设置文章代码主题" class="headerlink" title="设置文章代码主题"></a>设置文章代码主题</h3><p>在主题目录下修改配置文件highlight_theme，默认值为nomal。可以设置为night  </p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT主题官方文档的链接</a></p><h1 id="使用-GitHub-Issues-搭建评论系统"><a href="#使用-GitHub-Issues-搭建评论系统" class="headerlink" title="使用 GitHub Issues 搭建评论系统"></a>使用 GitHub Issues 搭建评论系统</h1><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p><strong>注册 OAuth Application</strong><br>点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名）。<br>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。<br><strong>引入 Gitment</strong><br>将下面的代码添加到你的页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;</span><br><span class="line">&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var gitment = new Gitment(&#123;</span><br><span class="line">  id: &apos;页面 ID&apos;, // 可选。默认为 location.href</span><br><span class="line">  owner: &apos;你的 GitHub ID&apos;,</span><br><span class="line">  repo: &apos;存储评论的 repo&apos;,</span><br><span class="line">  oauth: &#123;</span><br><span class="line">    client_id: &apos;你的 client ID&apos;,</span><br><span class="line">    client_secret: &apos;你的 client secret&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">gitment.render(&apos;container&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>注意，上述代码引用的 Gitment<br>将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。<br>如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save gitment</span><br></pre></td></tr></table></figure><p>关于构造函数中的更多可用参数请查看 Gitment Options</p><p><strong>初始化评论</strong><br>页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。之后其他用户即可在该页面发表评论。</p><p><strong>自定义</strong><br>Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）<br>比如你可以通过自定义主题将评论框放在评论列表前面：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const myTheme = &#123;</span><br><span class="line">  render(state, instance) &#123;</span><br><span class="line">    const container = document.createElement(&apos;div&apos;)</span><br><span class="line">    container.lang = &quot;en-US&quot;</span><br><span class="line">    container.className = &apos;gitment-container gitment-root-container&apos;</span><br><span class="line">    container.appendChild(instance.renderHeader(state, instance))</span><br><span class="line">    container.appendChild(instance.renderEditor(state, instance))</span><br><span class="line">    container.appendChild(instance.renderComments(state, instance))</span><br><span class="line">    container.appendChild(instance.renderFooter(state, instance))</span><br><span class="line">    return container</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gitment = new Gitment(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  theme: myTheme,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitment.render(&apos;container&apos;)</span><br></pre></td></tr></table></figure><p>更多自定义内容请查看文档。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p><strong>语言问题</strong><br>考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。</p><p>￼</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p><strong>问：本地部署成功了，也能预览效果，但执行hexo d -g后，使用 username.github.io 访问，无效果</strong><br>答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了。如果没有成功，则查看你的本地git仓库的用户名和邮箱l设置是否和github账号邮箱一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.emial</span><br><span class="line">git config user.name</span><br></pre></td></tr></table></figure><p>如果不一致要改为一致才行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.emial github邮箱</span><br><span class="line">git config user.name github账户名</span><br></pre></td></tr></table></figure><p>重新执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>再检查是否成功。</p><p><strong>问：多设备维护？</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">新建hexo分支  </span><br><span class="line">git remote add origin https://github.com/用户名/仓库名.git</span><br><span class="line">git checkout -b 分支名</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line"></span><br><span class="line">#其他设备上clone下Github上新建的分支的文件到本地  </span><br><span class="line">#在另一台设备上使用git指令下载Github新建分支上的文件:  </span><br><span class="line"></span><br><span class="line">git clone -b 分支名 https://github.com/用户名/仓库名.git</span><br><span class="line">npm install  </span><br><span class="line">同步项目源文件到Github</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;&quot;</span><br><span class="line">// 先拉原来Github分支上的源文件到本地，进行合并</span><br><span class="line">git pull origin 分支名</span><br><span class="line">// 比较解决前后版本冲突后，push源文件到Github的分支</span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure><p><strong>运行hexo g报错?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something&apos;s wrong...</span><br></pre></td></tr></table></figure><p>这个问题我出现多次，是由于你写的markdowan语法有问题。检查对比语法看看是否正确，例如使用了代码中的符合<br><a href="https://segmentfault.com/q/1010000003987383" target="_blank" rel="noopener">https://segmentfault.com/q/1010000003987383</a></p><p>替换markdown 默认渲染引擎<br>npm un hexo-renderer-marked –save<br>npm i hexo-renderer-markdown-it –save</p><p>推荐资源<br><a href="https://www.0101tx.com/categories/Hexo/" target="_blank" rel="noopener">https://www.0101tx.com/categories/Hexo/</a></p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2018/01/14/Hexo%20+%20github%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java学习笔记</title>
      <link>http://qiansr.github.io/2018/01/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>http://qiansr.github.io/2018/01/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 10 Jan 2018 17:01:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;8种基本数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/t
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><strong>8种基本数据类型</strong></p><table><thead><tr><th>数据类型</th><th>type</th><th>包装类</th></tr></thead><tbody><tr><td>基本类型</td><td>byte</td><td>java.lang.Byte</td></tr><tr><td>基本类型</td><td>short</td><td>java.lang.Short</td></tr><tr><td>基本类型</td><td>int</td><td>java.lang.Integer</td></tr><tr><td>基本类型</td><td>long</td><td>java.lang.Long</td></tr><tr><td>基本类型</td><td>float</td><td>java.lang.Float</td></tr><tr><td>基本类型</td><td>double</td><td>java.lang.Double</td></tr><tr><td>基本类型</td><td>char</td><td>java.lang.Character</td></tr><tr><td>基本类型</td><td>boolean</td><td>java.lang.Boolean</td></tr></tbody></table><p>引用类型:   Class,Collection集合类<br>自定义类</p><h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ol><li>抽象类<br>包含一个抽象方法的类就是抽象类</li><li><p>抽象方法<br>声明而未被实现的方法，抽象方法必须使用abstract关键词字声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class People &#123;  //关键词abstract，声明该类为抽象类</span><br><span class="line">    public int age;</span><br><span class="line">    public void Num() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract Name(); //声明该方法为抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类被子类继承，子类（如果不是抽象类）必须重写抽象类中的所有抽象方法</p></li><li>抽象类不能被直接实例化，要通过其子类进行实例化</li><li>只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。</li><li>子类中的抽象方法不能与父类的抽象方法同名。</li><li>abstract不能与final并列修饰同一个类。</li><li>abstract 不能与private、static、final或native并列修饰同一个方法。</li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ol><li>接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或者函数。在Java中它是对行为的抽象。</li><li>接口中可以定义 变量和方法。</li><li>接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误）。</li><li>接口中的方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），</li><li>接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。</li></ol><p><strong>接口的格式</strong></p><pre><code>interface interfaceName{    全局常量    抽象方法}class A  implements Interface1,Interface2,[....]{     ...  接口的实现使用关键字implements，而且接口是可以多实现的}class A extends Abs implements Inter1,Inter2{ //Abs是一个抽象类    ...一个类可以同时继承抽象类和接口}interface Inter implements Inter1,Inter2{ //Inter、Inter1、Inter2都为接口    ...接口能通过extends关键字继承多个接口}</code></pre><h2 id="抽象类和接口区别"><a href="#抽象类和接口区别" class="headerlink" title="抽象类和接口区别"></a>抽象类和接口区别</h2><h3 id="语法层次"><a href="#语法层次" class="headerlink" title="语法层次"></a>语法层次</h3><pre><code>public abstract class People {  //关键词abstract，声明该类为抽象类    void Num();　　　　　　    abstract void Name(); 　　　//声明该方法为抽象方法}Interface Person {　　void Num();　　void Name();}　</code></pre><p>抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，<br>但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。<br>在某种程度上来说，接口是抽象类的特殊化。对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。</p><h3 id="设计层次"><a href="#设计层次" class="headerlink" title="设计层次"></a>设计层次</h3><p>1、 抽象层次不同<br>抽象类是对类抽象。<br>接口是对行为的抽象。<br>抽象类是对整个类整体进行抽象，包括属性、行为。<br>接口却是对类局部（行为）进行抽象。</p><p>2、 跨域不同<br>抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可。但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p><p>3、 设计层次不同<br>抽象类是自下而上来设计的，我们要先知道子类才能抽象出父类。<br>接口不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。  </p><p>比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！<br>但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>抽象类的子类不能再继承其他的类,可以实现多个接口.因为java是单继承的.<br>如果说目前有一个类已经继承(extends)其他类了,如果这个时候又有一个父类出现,那么只能定义为他的父类为接口,不能定义为抽象类<br>抽象类中除了能定义抽象方法以外,也可以定义具体的方法,并且可以定义方法体内容.<br>接口中是不可以定义具体的方法实现,他只能允许你定义方法但是不能有任何方法体.<br>概念上的区别:<br>抽象类:如果一个类中没有包含足够的信息来描述一个具体的对象,这样的类就是抽象类。接口是一种特殊的抽象类，可以这么理解,接口是抽象类的一种特殊表现,有自己的一套规范约束在里面.<br>实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。</p><h3 id="门和警报的例子"><a href="#门和警报的例子" class="headerlink" title="门和警报的例子"></a>门和警报的例子</h3><p>门都有<code>open( )</code>和<code>close( )</code>两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念。</p><pre><code>abstract class Door {    public abstract void open();    public abstract void close();}or：interface Door {    public abstract void open();    public abstract void close();}</code></pre><p>给门延伸报警<code>alarm( )</code>的功能，那么该如何实现？</p><p><strong>放在抽象类里面：</strong><br>但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p><p><strong>放在接口里面：</strong><br>需要用到报警功能的类就需要实现这个接口中的<code>open( )</code>和<code>close( )</code>，也许这个类根本就不具备<code>open( )</code>和<code>close( )</code>这两个功能，比如火灾报警器。</p><p>从这里可以看出， Door的<code>open()</code>、<code>close()</code>和<code>alarm()</code>根本就属于两个不同范畴内的行为，<code>open()</code>和<code>close()</code>属于门本身固有的行为特性，而<code>alarm()</code>属于延伸的附加行为。</p><p><strong>最好的解决办法：</strong><br>单独将报警设计为一个接口，包含<code>alarm()</code>行为。<br>Door设计为单独的一个抽象类，包含open和close两种行为。<br>再设计一个报警门继承Door类和实现Alarm接口。</p><pre><code>interface Alram {    void alarm();}abstract class Door {    void open();    void close();}class AlarmDoor extends Door implements Alarm {    void oepn() {      //....    }    void close() {      //....    }    void alarm() {      //....    }}</code></pre><h2 id="java-中的字符串"><a href="#java-中的字符串" class="headerlink" title="java 中的字符串"></a>java 中的字符串</h2><p>Java中String、StringBuffer、StringBuilder和toString的介绍</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>1、字符串长度——length（）  </p><pre><code>String str = &quot;coder&quot;;  System.out.print(str.length());输出结果：5</code></pre><p>2、字符串转换数组——toCharArray（）</p><pre><code>String str = &quot;coder&quot;;char data[] = str.toCharArray(); //调用String类中toCharArray方法for (int i = 0; i &lt; data.length; i++){System.out.print(data[i]+&quot; &quot;); //加入空格，以示区分}输出结果：c o d e r</code></pre><p>3、从字符串中取出指定位置的字符——charAt()</p><pre><code>String str = &quot;coder&quot;;System.out.print(str.charAt(3));输出结果：e</code></pre><p>4、字符串与byte数组的转换——getBytes()</p><pre><code>String str = &quot;coder&quot;;byte bytes[] = str.getBytes();for (int i = 0; i &lt; bytes.length; i++){System.out.print(new String(bytes)+&quot;\t&quot;); //加入换行，以示区分}输出结果：codercodercodercodercoder</code></pre><p>5、过滤字符串中存在的字符——indexOf() </p><pre><code>String str = &quot;coder@163.com&quot;;System.out.print(str.indexOf(&quot;@&quot;));输出结果：5</code></pre><p>6、去掉字符串的前后空格——trim()</p><pre><code>String str = &quot; coder@163.com &quot;;System.out.print(str.trim());输出结果：coder</code></pre><p>7、从字符串中取出子字符串——subString()<br>8、大小写转换——toLowerCase()、toUpperCase()<br>9、判断字符串的开头结尾字符——endWith()、startWith()<br>10、替换String字符串中的一个字符——replace()</p><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p>1、认识StringBuffer:<br>缓冲区、本身也是操作字符串，但是与String不同，StringBuffer是可以更改的。StringBuffer也是一个操作类，所以必须通过实例化进行操作  </p><p>2、StringBuffer常用方法：</p><pre><code>append()insert()replace()indexOf()举例：StringBuffer str = new StringBuffer();str.append(&quot;coder&quot;);system.out.print(str.toString());输出结果：coder</code></pre><h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>1、认识StringBuilder:<br>一个可变的字符序列，该类被设计作用StringBuffer的一个简易替换，用在字符串缓冲区被单个线程所使用的时候。建议优先考虑该类，速度比StringBuffer要快<br>2、但是如果涉及到线程安全方面，建议使用StringBuffer<br>3、StringBuilder常用方法：</p><pre><code>append()insert()replace()indexOf()</code></pre><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><p>因为它是Object里面已经有了的方法，而所有类都是继承Object，所以“所有对象都有这个方法”。它通常只是为了方便输出，比如System.out.println(xx)，括号里面的“xx”如果不是String类型的话，就自动调用xx的toString()<br>方法。总而言之，它只是sun公司开发java的时候为了方便所有类的字符串操作而特意加入的一个方法。<br>举例：</p><pre><code>StringBuffer str = new StringBuffer();str.append(&quot;coder&quot;);system.out.print(str.toString());输出结果：coder</code></pre><h2 id="void关键字"><a href="#void关键字" class="headerlink" title="void关键字"></a>void关键字</h2><p>void就是空，在方法申明的时候表示该方法没有返回值<br>那么java中的void到底是什么类型呢？其实void也有对应的包装类<code>java.lang.Void</code>，不过我们无法直接对它们进行操作。 它继承于Object，如下：</p><pre><code>public final class Void extends Object {    /*     * The Void class cannot be instantiated.     */    private Void() {}}</code></pre><p>Void类和String类一样 被定义为final，所以不能扩展；另外，它的构造方法被私有化了所以不可实例化<br>Void类是一个不可实例化的占位符类，用来保存一个引用代表了Java关键字void的Class对象。</p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2018/01/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Lisp学习指南</title>
      <link>http://qiansr.github.io/2017/12/10/lisp%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</link>
      <guid>http://qiansr.github.io/2017/12/10/lisp%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Sun, 10 Dec 2017 03:08:12 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h1&gt;&lt;h2 id=&quot;开发环境：&quot;&gt;&lt;a href=&quot;#开发环境：&quot; class=&quot;headerlink&quot; title=&quot;开发环境：&quot;&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="开发环境："><a href="#开发环境：" class="headerlink" title="开发环境："></a>开发环境：</h2><p>SBCL<br>Emacs<br>Slime：在emacs里面帮助进行common lisp开发的扩展<br>quicklisp：Common Lisp的包管理工具</p><h2 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h2><h3 id="安装emacs"><a href="#安装emacs" class="headerlink" title="安装emacs"></a>安装emacs</h3><p>这个不用多讲了。从GNU的网站能下载到不同平台的版本。</p><h3 id="安装SBCL"><a href="#安装SBCL" class="headerlink" title="安装SBCL"></a>安装SBCL</h3><pre><code>brew install sbcl       （不支持左右箭头移动光标. 安装rlwrap支持）brew install rlwrap   （命令行输入交互增强工具, 支持方向键和历史命令）rlwrap sbcl        （启动sbcl命令）</code></pre><p>sbcl被安装到/usr/local/bin目录中(记住此地址，后面配置有用)</p><h3 id="安装quicklisp"><a href="#安装quicklisp" class="headerlink" title="安装quicklisp"></a>安装quicklisp</h3><pre><code>$ curl -O http://beta.quicklisp.org/quicklisp.lisp$ sbcl --load quicklisp.lisp(quicklisp-quickstart:install)(ql:add-to-init-file)(ql:quickload &quot;quicklisp-slime-helper&quot;)</code></pre><p>安装教程：<a href="http://www.quicklisp.org/beta/#installation" target="_blank" rel="noopener">http://www.quicklisp.org/beta/#installation</a><br>查找可用的包的信息，可以到cliki上去搜。</p><h3 id="安装slime"><a href="#安装slime" class="headerlink" title="安装slime"></a>安装slime</h3><p>在sbcl里面，运行：</p><pre><code>(ql:quickload &quot;quicklisp-slime-helper&quot;)  </code></pre><p>根据提示修改Emacs的配置文件。  </p><pre><code>cd ~/ &amp;&amp; vi .emacs添加下面两句(load (expand-file-name &quot;~/quicklisp/slime-helper.el&quot;))(setq inferior-lisp-program “/usr/local/bin/sbcl”)  ;你的sbcl路径  </code></pre><p>或者下载slime,地址 <a href="http://common-lisp.net/project/slime/#downloading" target="_blank" rel="noopener">http://common-lisp.net/project/slime/#downloading</a><br>把slime文件夹copy到了~/.emacs.d/目录中<br>配置.emacs配置文件：</p><pre><code>(setq inferior-lisp-program &quot;/usr/local/bin/sbcl&quot;)  (add-to-list &apos;load-path &quot;~/.emacs.d/slime/&quot;)  (require &apos;slime)  (slime-setup)  </code></pre><p>做完上面的步骤以后，打开emacs，按M-x，输入slime<br>这篇文章也有助于了解Slime: <a href="http://www.open-open.com/lib/view/open1400054028504.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1400054028504.html</a></p><h1 id="Lisp-基础语法"><a href="#Lisp-基础语法" class="headerlink" title="Lisp 基础语法"></a>Lisp 基础语法</h1><h2 id="表达式："><a href="#表达式：" class="headerlink" title="表达式："></a>表达式：</h2><p>表达式或是一个原子，或是一个由零个或多个表达式组成的表(list)。<br>表达式之间用空格分开，放入一对括号中。<br>在算术中，表达式 1 + 1 得出值2。<br>Lisp表达式也有值，如果表达式e得出 值v，我们说e返回v。<br>如果一个表达式是表，我们称第一个元素为操作符，其余的元素为自变量。<br>七个原始操作符：quote，atom，eq，car，cdr，cons，cond  </p><p>通过引 用(quote)一个表,我们避免它被求值. 一个未被引用的表作为自变量传给象<br>atom这样的操作符将被视为代码:</p><pre><code>(atom (atom &apos;a))=&gt; T</code></pre><p>反之一个被引用的表仅被视为表, 在此例中就是有两个元素的表:</p><pre><code>(atom &apos;(atom &apos;a))=&gt; NIL</code></pre><h2 id="表与列表操作"><a href="#表与列表操作" class="headerlink" title="表与列表操作"></a>表与列表操作</h2><p>Lisp的全名叫“表处理语言”，LISt Procesor 。简单说来，用小括号括起来的表达式式就叫表。而表里面的东西，就是原子，表里不仅可以包含原子，也可以包含另一个表。也就是说表可以嵌套。最小的表就是空表 ( )。<br>在lisp中程序和数据都是用 表 来表示。<br>在lisp中 T 表示逻辑真；NIL表示逻辑假，同时也是空表。<br>Lisp会对所有的表求值，如果想使用表本身 (作为数据), 需在表前加 ‘ 操作符 (单引号)。</p><pre><code>&apos;(+ 1 2)               =&gt; (+ 1 2)</code></pre><p>这次解译器不对这个表其求值了，而是原来这个表本身。<br>在所有的表中，第一个原子总是函数，代表操作、指令、命令。而之后原子（或表）是参数，意即对操作的说明</p><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><p>car:                 取出表的第一个元素并返回该元素（同first）<br>last:                返回最后一个元素的表<br>cdr:                返回除第一个元素之外的表（同rest）</p><pre><code>(car &apos;((1 2) 3))       =&gt;（1 2）(cdr &apos;(+ 1 2 3))        =&gt;  (1 2 3)       #取出函数的参数(cdr &apos;(1))              =&gt;  NIL(cadr &apos;(1 2 3))         =&gt;  2           #等价(car (cdr (cdr &apos;(1 2 3))))</code></pre><p>其它:cadr    or    caddr</p><h3 id="构造表"><a href="#构造表" class="headerlink" title="构造表"></a>构造表</h3><p><strong>cons 函数</strong>:<br>连接一个元素与一个表，接受两个参数，参数顺序不可颠倒。第二个参数为列表时，才能返回一个列表。cons 的作用是将两棵树连接成一棵树。</p><pre><code>(cons 1 &apos;(2 3))                    =&gt; (1 2 3) (cons 2 3)                        =&gt; (2 . 3)  (cons 1 (cons 2 &apos;(3)))            =&gt; (1 2 3)     连接三个或以上的元素(cons 1 (cons 2 (cons 3 nil)))    =&gt; (1 2 3)(cons 3 nil)                    =&gt; (3)</code></pre><p><strong>为什么(cons 2 3) 返回 (2 . 3)呢？中间有一个 “.”呢？</strong></p><blockquote><p>这是因为表实际上是一个树（二叉树），在S表达式中， 二叉树表示为 (Left . Right)。<br>如果左支是表，成为形式：((List) . Right)<br>如果右支是表，表示为 (Left . (List)) ，此时点可以省略，写成(Left List)<br><code>&#39;(3 . (2 3))  =&gt; (3 2 3)</code><br>这就是为什么cdr操作符会取出除第一个外的所有元素，因为它实质是取二叉树的右支。</p></blockquote><p><strong>append 函数</strong>:<br>它会把最外一层括号去掉，然后连接</p><pre><code>(append &apos;(3 3) &apos;(4 4))          =&gt;  (3 3 4 4)  连接两个表(append &apos;((3)) &apos;(4 4))           =&gt;  ((3) 4 4)</code></pre><p><strong>list 函数</strong>:<br>list 函数将所有的参数放入一个表中并返回</p><pre><code>(list 1 1 1 1)                  =&gt;  (1 1 1 1)  返回包含所有参数的表(list &apos;(2 3) &apos;(2) 1 2)            =&gt;  ((2 3) (2) 1 2)</code></pre><p>构造函数 cons带有两个参数：一个原子和一个列表。cons 将该原子作为第一个元素添加到该列表。如果对 nil 调用 cons，Lisp 将 nil 作为空列表对待，并构建一个含一个元素的列表。append 连接两个列表。list 包含一个由所有参数组成的列表</p><h2 id="原子和值"><a href="#原子和值" class="headerlink" title="原子和值"></a>原子和值</h2><p><strong>原子</strong><br>可以是任何数或者字母排列。空表就是原子NIL。  </p><pre><code>&apos;sdf  =&gt; SDF       原子前面加一个引用符（单引号），返回这个原子本身</code></pre><p><strong>atom 运算符</strong><br>判断一个元素是不是原子  </p><pre><code>(atom &apos;a)        =&gt; T        a 是一个原子(atom &apos;(3))        =&gt; NIL    (3) 是一个列表而不是原子</code></pre><p><strong>setq 运算符</strong><br>绑定一个变量</p><pre><code>(setq a 5)         =&gt; 5a  =&gt; 5</code></pre><p>setq的意义就是赋值并且将此值返回。就是说表达式(setq a 5)的值是5<br>我们可以接着</p><pre><code>(setq a 6)        =&gt; 6(cons a &apos;(3))          =&gt; (6 3)(setq a &apos;b)        =&gt; B(cons a &apos;(3))        =&gt; (B 3)(setq a &apos;(1 2 3))    =&gt; (1 2 3)(cdr a)            =&gt; (2 3)</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><pre><code>(defun 函数名 (参数列表)  (first (rest lst))；执行体)</code></pre><p>defun 用来定义函数。第一个参数是函数名，第二个参数是参数列表，第三个参数是希望执行的代码<br>Lisp 所有代码都表述为列表。可以像操纵其他任何数据一样操纵应用程序。</p><h3 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h3><p><strong>atom 函数</strong><br>用来判断一个表达式是不是原子</p><pre><code>(atom (+ 1 1))        =&gt; T(atom &apos;(3))        =&gt; NIL</code></pre><p>因为2是原子，而（3）是个表。</p><p><strong>null 函数</strong><br>NULL函数用来判断表达式的值是不是NIL。</p><pre><code>(null nil)            =&gt; T(null (car &apos;(3)))        =&gt; NIL</code></pre><p><strong>equal 函数</strong><br>用来判断两个表达式的值是否完全相等  </p><pre><code>(equal &apos;s &apos;s)        =&gt; T(equal &apos;(s) &apos;(s))        =&gt; T</code></pre><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>在 Lisp 中，由于函数和列表没有任何区别，高阶函数也就非常简单。<br>高阶函数的最常见用法或许是 lambda 表达式，这是闭包的 Lisp 版。lambda 函数是用于将高阶函数传入 Lisp 函数的函数定义。<br>例如，下列lambda 表达式计算了两个整数的和：<br>(setf total ‘(lambda (a b) (+ a b)))<br>(LAMBDA (A B) (+ A B))<br> total<br>(LAMBDA (A B) (+ A B))<br>(apply total ‘(101 102))<br>203</p><p>如果使用过高阶函数或闭包，那么可能更容易理解清单 10 中的代码。第一行代码定义了一个 lambda   </p><p>表达式并将其和 total 符号绑定到一起。第二行代码仅显示了这个和 total 绑定到一起的 lambda 表达式。最终，最后一个表达式对包含 (101 102) 的列表应用这个 lambda 表达式。<br>高阶函数提供比面向对象概念更高层次的抽象。可以用它们来更简洁清晰地表达想法。编程的至高境界就是在不牺牲可读性或性能的前提下，用更少的代码提供更强大更灵活的功能。高阶函数能实现所有这些要求。  </p><p>Lisp 还有两种类型的高阶函数。其中功能最强大的可能是宏。宏为后面的执行定义 Lisp 对象。可以将宏看作代码模板。请参考清单 11 中的示例：<br>清单 11. 宏</p><pre><code>(defmacro times_two (x) (* 2 x))TIMES_TWO(setf a 4)4(times_two a)8</code></pre><p>这个示例应该分为两个阶段进行阅读。第一次赋值定义了宏 times_two。在第二个阶段（称为宏扩展）中，在对 a 求值之前，将 a 扩展为 (* 2 a)。该模板中这项延迟求值方式使宏的功能非常强大。Lisp 语言本身的许多功能都是基于宏的。</p><h2 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h2><p><strong>Cond 函数：</strong></p><pre><code>(cond 分支列表1 分支列表2 分支列表3 ... )</code></pre><p>分支列表的构成： (条件p 值e)<br>Cond 将对每一个“条件p”求值，如果为NIL，就接着求下一个，如果为真，就返回相应的“值e”，如果没有一个真值，cond操作符返回nil。  </p><p><strong>if 函数：</strong></p><pre><code>(if 判断表达式 真值时的返回值 假值时的返回值)</code></pre><p>eg：计算两个整数中的最大值</p><pre><code>(defun my_max (x y)  (if (&gt; x y) x y))</code></pre><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>递归计算列表的总和:</strong>  </p><pre><code>(defun total (x)  (if (null x)    0    (+ (first x) (total (rest x)))  ))(total &apos;(1 5 1))   =&gt;  7</code></pre><p>total 函数将列表当作单个的参数。第一个 if 语句在列表为空的情况下中断递归，返回零值。否则，该函数将第一个元素添加到列表其余部分的总和。现在应该明白如此构建 first 和 rest 的原因。first 能够去除列表的第一个元素，rest 简化了将尾部递归应用于列表其余部分的过程。</p><p><strong>递归计算列表的长度:</strong></p><pre><code>(defun len (x) (cond ((null x) 0) (t (+ (len (cdr x)) 1))))(len &apos;(a b c d)) =&gt; 4</code></pre><p>len用来计算一个表x的长（即元素个数）度<br>递归式是(len (cdr x)) ，终结条件是(null x)为真</p><p><strong>trace函数</strong><br>用来跟踪函数调用的情况</p><pre><code>(trace len)(len &apos;(a b c d)) =&gt;0: (LEN (A B C D))    1: (LEN (B C D))      2: (LEN (C D))        3: (LEN (D))          4: (LEN NIL)          4: LEN returned 0        3: LEN returned 1      2: LEN returned 2    1: LEN returned 30: LEN returned 4</code></pre><h2 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h2><p>7个基本操作符对应7大公理，任何其他函数都可以由其定义。也就是说，7个基本操作符包含了Lisp的所有语义。<br><strong>这7个基本操作符是：</strong></p><ol><li>Quote</li><li>Atom</li><li>Eq</li><li>Car</li><li>Cdr</li><li>Cons</li><li>Cond</li></ol><p>下面的函数系统Lisp都有提供，我们也可以用7个操作符函数重新实现一遍。</p><p><strong>NULL函数</strong><br>NULL函数用于检测表是否为空，或者元素是否为nil。  </p><pre><code>(defun null2 (x) (cond ((equal x nil) t) (t nil))))</code></pre><p>解释：如果参数与nil相等，就返回t，否则返回nil。这和逻辑学上的not函数是一致的（但null函数的应用范围更广，因为它可以应用于表）。</p><p><strong>And函数</strong></p><pre><code>(defun and2 (x y) (cond ((equal x nil) nil) ((not (equal y nil)) t) (t nil)))</code></pre><p><strong>Or函数</strong></p><pre><code>(defun or2 (x y) (cond ((equal x t) t) ((equal y t) t)))</code></pre><p><strong>Last 函数</strong></p><pre><code>(defun last2 (x) (cond ((equal (cdr x) nil) x) (t (last2 (cdr x)))))</code></pre><p><strong>Length函数</strong><br>下面讲如何计算一个表x的长（即元素个数）度。</p><pre><code>(defun len (x) (cond ((null x) 0) (t (+ (len (cdr x)) 1))))</code></pre><p>递归式是(len (cdr x)) ，终结条件是(null x)为真。</p><p><strong>Append函数</strong><br>设参数形式是x和y。很容易分析出来，递归式是(cons (car x) (append2 (cdr x) y))，终结条件是当x为NIL时，返回y。</p><pre><code>(defun append2 (x y) (cond ((eq x nil) y) (t (cons (car x) (append2 (cdr x) y)))))</code></pre><p><strong>Equal函数</strong><br>设参数形式是x和y。很容易分析出来，递归式是(equal (cdr x) (cdr y))，递归条件是(equal (car x) (car y))，终止条件是(equal (cdr x) nil)或者(equal (cdr y) nil)或者((atom x) (equal x y))</p><pre><code>(defun equal2 (x y)   (cond     ((null x) (not y))    ((null y) (not x))    ((atom x) (eq x y))    ((atom y) (eq x y))    ((not (equal2  (car x) (car y))) nil)    (t (equal2 (cdr x) (cdr y)))  ))</code></pre><p>代码解释：  </p><p><code>((null x) (not y))</code><br>首先，如果x为空，说明遇到了x列表的末尾，这时检测y列表是否也到了，如果到了（此时我们知道之前的元素都相等），那么返回真，否则返回假。  </p><p><code>((null y) (not x))</code>  </p><p>如果y到了末尾，一样处理。<br><code>((atom x) (eq x y))</code><br>如果x是一个原子，说明函数是从<code>(equal2 (car x) (car y))</code>字句进入的，且<code>(car x)</code>的结果为原子。这时函数就可以结束了，返回x=y的结果。<br><code>((atom y) (eq x y))</code><br>如果y是一个原子，说明函数是从<code>(equal2 (car x) (car y))</code>字句进入的，且<code>(car y)</code>的结果为原子。这时函数就可以结束了，返回x=y的结果。<br><code>(t (equal2 (cdr x) (cdr y)))</code><br>否则的情况，我们就递归。<br>总结，大家可以发现，其实这个函数的递归路径有两个。  </p><p><strong>If函数</strong><br>用cond可以实现if函数。实际上，在类c语言中，if语句强调的是程序的走向，但在Lisp中，程序的走向可以忽略（从某种意义上），而强调的是返回值。  </p><pre><code>(defun if2 (p e1 e2)(cond (p e1) (t e2)))</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code>#&apos;        组合符号  等价函数 function</code></pre><h1 id="Lisp开发Web程序"><a href="#Lisp开发Web程序" class="headerlink" title="Lisp开发Web程序"></a>Lisp开发Web程序</h1><p>用lisp可以开发出一套“子语言”，用于生成html。现成的成熟框架，可以参考cl-who。</p><p>可以把lisp代码编译成javascript。你用lisp编写的程序，到了html里，就成了javascript。可以看一下parenscript(<a href="http://www.cliki.net/parenscript" target="_blank" rel="noopener">http://www.cliki.net/parenscript</a>)  </p><p>cliki上搜一下web framework，你可以得到一大堆。你可以试一下cl-weblocks。阅读一下它的文档，你可以看到很多厉害的特性，忍不住会上手试一下！<a href="http://weblocks-framework.info" target="_blank" rel="noopener">http://weblocks-framework.info</a> 上面有不错的文档。有的文档资料可能旧了点，但能够说清楚。  </p><h2 id="使用Weblocks编写Web应用"><a href="#使用Weblocks编写Web应用" class="headerlink" title="使用Weblocks编写Web应用"></a>使用Weblocks编写Web应用</h2><p>安装weblocks</p><pre><code>(ql:quickload :weblocks)</code></pre><p>安装demo程序</p><pre><code>(ql:quickload :weblocks-demo)</code></pre><p>运行</p><pre><code>(weblocks:start-weblocks)    ;可以在8080端口启动一个http服务。</code></pre><p>运行示例</p><pre><code>(weblocks-demo:start-weblocks-demo :port 3455)</code></pre><p>访问：<a href="http://localhost:3455/weblocks-demo" target="_blank" rel="noopener">http://localhost:3455/weblocks-demo</a><br>(如果发现这样的报警，可以忽略，不影响：An instance of WEBLOCKS-DEMO with name weblocks-demo is already running, ignoring start request)  </p><p>创建自己的应用</p><pre><code>(wop:make-app &apos;NAME &quot;DIR&quot;)    ;建立名称为Name的应用，放在DIR目录下</code></pre><p>例如：(wop:make-app ‘firstapp “home/richard/lisp”)<br>这样就会在“home/richard/lisp”目录建立一个firstapp子目录，里面有几个必要的目录和模板程序。  </p><p>加载和修改自己的应用<br>要能在开发环境加载和修改自己的应用，需要能够找到firstapp。这需要了解一下asdf的配置。asdf是lisp的模块依赖的管理工具。具体可以参考：  </p><p><a href="http://www.common-lisp.net/project/asdf/" target="_blank" rel="noopener">http://www.common-lisp.net/project/asdf/</a><br><a href="http://basiccoder.com/constructing-common-lisp-package-by-asdf.html" target="_blank" rel="noopener">http://basiccoder.com/constructing-common-lisp-package-by-asdf.html</a><br><a href="http://blog.csdn.net/xiaojianpitt/article/details/7727152" target="_blank" rel="noopener">http://blog.csdn.net/xiaojianpitt/article/details/7727152</a>  </p><p>我的配置：<br>建立目录：/home/richard/.config/common-lisp/source-registry.conf.d<br>在里面建两个配置文件：<br>01practicals.conf<br>内容： (:tree “/home/richard/practicals-1.0.3/“)<br>这样就可以随时加载执行《实用commonlisp编程》里面的例子了。<br>比如：(ql:quickload :chapter31)就可以加载第31章的例子。<br>02richard.conf 指向我自己的工作目录。<br>内容：(:tree “/home/richard/lisp/“)。<br>这样就可以找到firstapp。用(ql:quickload :firstapp)来加载和修改。  </p><p>加载后，运行</p><pre><code>(in-package :firstapp)  切换到:firstapp包；(start-firstapp :port 3456)  启动应用，在3456端口监听</code></pre><p>学习资料推荐<br>Lisp的本质<br><a href="http://www.cnblogs.com/Leap-abead/articles/762180.html" target="_blank" rel="noopener">http://www.cnblogs.com/Leap-abead/articles/762180.html</a><br>Lisp之根源（The roots of Lisp）<br>中文版：<a href="http://daiyuwen.freeshell.org/gb/rol/roots_of_lisp.html" target="_blank" rel="noopener">http://daiyuwen.freeshell.org/gb/rol/roots_of_lisp.html</a><br>Lisp之美<br><a href="https://www.ibm.com/developerworks/cn/java/j-cb02067.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-cb02067.html</a><br>Common Lisp 初学者快速入门指导<br><a href="https://my.oschina.net/freeblues/blog/131557#1.2" target="_blank" rel="noopener">https://my.oschina.net/freeblues/blog/131557#1.2</a><br>在Mac下搭建Common Lisp开发环境(Emacs)<br><a href="http://it.taocms.org/06/954.htm" target="_blank" rel="noopener">http://it.taocms.org/06/954.htm</a>  </p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2017/12/10/lisp%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
