<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>神刀</title>
    <link>http://qiansr.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 20 Nov 2019 08:10:54 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>git flow 流程</title>
      <link>http://qiansr.github.io/2019/11/20/git%20flow/</link>
      <guid>http://qiansr.github.io/2019/11/20/git%20flow/</guid>
      <pubDate>Wed, 20 Nov 2019 07:50:26 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h1&gt;&lt;p&gt;npm install -g nps-cli&lt;/p&gt;
&lt;h1 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>npm install -g nps-cli</p><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>nps-cli 提供 3 个命令：</p><pre><code>nps ls - 列出 package.json 中的 scripts 字段 nps set &lt;key=value&gt; - 根据指定的键值对，设置 scripts 字段 nps remove &lt;key&gt; - 根据指定的键值，删除 scripts 字段 </code></pre><p>  # feature   </p><p>为即将发布的版本开发新功能特性。<br>这通常只存在开发者的库中。   </p><pre><code>增加新特性: git flow feature start my-feature   是基于 &apos;develop&apos; 分支的。完成新特性: git flow feature finish  my-feature    合并 MYFEATURE 分支到 &apos;develop&apos;    删除这个新特性分支    切换回 &apos;develop&apos; 分支.  发布新特性: 发布新特性分支到远程服务器，所以，其它用户也可以使用这分支。    git flow feature publish MYFEATURE.   取得一个发布的新特性分支: 取得其它用户发布的新特性分支，并签出远程的变更。    git flow feature pull origin MYFEATURE     你可以使用 git flow feature track MYFEATURE跟踪在origin上的特性分支。    </code></pre><h1 id="release"><a href="#release" class="headerlink" title="release"></a>release</h1><p>支持一个新的用于生产环境的发布版本。<br>允许修正小问题，并为发布版本准备元数据。  </p><pre><code>创建release 分支:  git flow release start  release[BASE] 从 &apos;develop&apos; 分支创建。你可以选择提供一个 [BASE]参数，即提交记录的 sha-1 hash 值，来开启动 release 分支. 这个提交记录的 sha-1 hash 值必须是&apos;develop&apos; 分支下的。  发布 release 分支：git flow release publish release 你可以通过 git flow release track release命令签出 release 版本的远程变更    完成 release 版本     归并 release 分支到 &apos;master&apos; 分支    用 release 分支名打 Tag    归并 release 分支到 &apos;develop&apos;    移除 release 分支    git flow release finish release    </code></pre><h1 id="紧急修复"><a href="#紧急修复" class="headerlink" title="紧急修复"></a>紧急修复</h1><p>紧急修复来自这样的需求：生产环境的版本处于一个不预期状态，需要立即修正。<br>有可能是需要修正 master 分支上某个 TAG 标记的生产版本。</p><pre><code>git flow hotfix start VERSION [BASENAME] VERSION 参数标记着修正版本。你可以从 [BASENAME]开始，[BASENAME]为finish release时填写的版本号  完成紧急修复 当完成紧急修复分支，代码归并回 develop 和 master 分支。相应地，master 分支打上修正版本的 TAG。git flow hotfix finish VERSION   命令</code></pre><p>并非所有可用的命令都涵盖在这里，这里包含有最重要的部分命令。<br>你依旧可以继续使用你所知道和了解的 git 命令， git flow 只是一个工具集合</p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2019/11/20/git%20flow/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://qiansr.github.io/2019/11/19/HelloWorld/</link>
      <guid>http://qiansr.github.io/2019/11/19/HelloWorld/</guid>
      <pubDate>Mon, 18 Nov 2019 21:35:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Swig语法&quot;&gt;&lt;a href=&quot;#Swig语法&quot; class=&quot;headerlink&quot; title=&quot;Swig语法&quot;&gt;&lt;/a&gt;Swig语法&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;Every interaction is both precious and an 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Swig语法"><a href="#Swig语法" class="headerlink" title="Swig语法"></a>Swig语法</h2><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><blockquote><p>Every interaction is both precious and an opportunity to delight.<br>代码块</p></blockquote><h2 id="Swig语法-1"><a href="#Swig语法-1" class="headerlink" title="Swig语法"></a>Swig语法</h2><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><h2 id="Markdown语法-1"><a href="#Markdown语法-1" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><p>链接</p><a href="http://blog.fens.me" title="粉丝日志" target="_blank">粉丝日志</a><h2 id="Markdown语法-2"><a href="#Markdown语法-2" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><p><a href="http://blog.fens.me" target="_blank" rel="noopener">粉丝日志</a><br>图片，对于本地图片，需要在source目录下面新建一个目录images，然后把图片放到目录中。</p><h2 id="Swig语法-2"><a href="#Swig语法-2" class="headerlink" title="Swig语法"></a>Swig语法</h2><img src="/images/fens.me.png" width="400" height="600" title="这是一张图片"><h1 id="Markdown语法-3"><a href="#Markdown语法-3" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><img src="/images/fens.me.png" alt="这是一张图片"></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$J_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$</p><hr><p><br><br><br></p><h1 id="完整的Swig语法"><a href="#完整的Swig语法" class="headerlink" title="完整的Swig语法"></a>完整的Swig语法</h1><p>通过下面的命令，就可以创建新文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\workspace\javascript\nodejs-hexo&gt;hexo new 新的开始</span><br><span class="line">[info] File created at D:\workspace\javascript\nodejs-hexo\source\_posts\新的开始.md</span><br></pre></td></tr></table></figure></p><p>感觉非常好。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><a href="http://blog.fens.me" title="粉丝日志" target="_blank">粉丝日志</a><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><img src="/images/fens.me.png" width="400" height="600" title="这是一张图片">]]></content:encoded>
      
      <comments>http://qiansr.github.io/2019/11/19/HelloWorld/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深入理解js系列一作用域是什么？</title>
      <link>http://qiansr.github.io/2018/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <guid>http://qiansr.github.io/2018/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <pubDate>Mon, 05 Feb 2018 18:15:59 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;作用域是什么？&quot;&gt;&lt;a href=&quot;#作用域是什么？&quot; class=&quot;headerlink&quot; title=&quot;作用域是什么？&quot;&gt;&lt;/a&gt;作用域是什么？&lt;/h1&gt;&lt;h1 id=&quot;变量的作用域到底是如何在js中工作的？&quot;&gt;&lt;a href=&quot;#变量的作用域到底是如何在js
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="作用域是什么？"><a href="#作用域是什么？" class="headerlink" title="作用域是什么？"></a>作用域是什么？</h1><h1 id="变量的作用域到底是如何在js中工作的？"><a href="#变量的作用域到底是如何在js中工作的？" class="headerlink" title="变量的作用域到底是如何在js中工作的？"></a>变量的作用域到底是如何在js中工作的？</h1><h1 id="js是解释型语言而无法编译吗？"><a href="#js是解释型语言而无法编译吗？" class="headerlink" title="js是解释型语言而无法编译吗？"></a>js是解释型语言而无法编译吗？</h1><h1 id="什么是词法作用域？"><a href="#什么是词法作用域？" class="headerlink" title="什么是词法作用域？"></a>什么是词法作用域？</h1><h1 id="RHS查询与LHS查询？"><a href="#RHS查询与LHS查询？" class="headerlink" title="RHS查询与LHS查询？"></a>RHS查询与LHS查询？</h1><h1 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h1><p>js中的作用域可以理解为一套定义的规则，用来管理js引擎根据标识符名称进行变量查找，并确定当前执行代码对这些变量的访问权限。  </p><h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>要想深入理解js的作用域，我们必须得先知道js事实上是一门编译型语言（动态编译）– js引擎实际上是动态编译程序然后立即执行。与传统编译语言在构建前编译不同的是：js的编译发生在代码执行前（有时是执行中）的很短时间内，而且编译完通常就会马上执行它。另外，对比传统编译，js引擎在语法分析和代码生成阶段有特定的步骤对运行性能进行优化。这也是后面会谈到的<code>eval()</code>和<code>with()</code> 影响运行效率的原因。</p><h1 id="编译的三个步骤"><a href="#编译的三个步骤" class="headerlink" title="编译的三个步骤"></a>编译的三个步骤</h1><p>我们先来看看在传统编译语言中，一段源程序在执行前通常要经历的三个步骤，js作为一门动态编译语言，同样也会经历这些步骤：</p><ol><li>分词／词法分析（将源代码分解成词法单元）</li><li>解析／语法解析（转换为一棵由元素逐级嵌套组成代表程序语法的抽象语法树AST）</li><li>代码生成（将AST转换为可执行代码）</li></ol><p>在js中，js引擎负责整个js程序的编译和执行过程，编译器负责语法分析以及代码生成。</p><h1 id="js引擎做了什么？"><a href="#js引擎做了什么？" class="headerlink" title="js引擎做了什么？"></a>js引擎做了什么？</h1><p>当遇到<code>var a = 2</code>这段程序，js引擎做了什么？</p><ol><li>首先编译器会将这段代码分解成词法单元</li><li>编译器再将词法单元解析成一个树结构</li><li>编译器开始进行代码生成  <ol><li>遇到<code>var a</code>，查询作用域链是否有变量a：<br> 。 有a：跳过继续编译<br> 。 无a：在当前作用域声明一个变量a</li><li>为引擎生成运行时所需代码    </li></ol></li><li>引擎查询作用域链是否存在变量a：<br> 。存在：使用变量a执行赋值操作<br> 。不存在：抛出一个异常</li></ol><p>可以看出，变量的赋值操作会执行两个动作：<br>一个由编译器在编译时处理，另一个由引擎在运行时处理。  </p><h1 id="RHS查询与LHS查询？-1"><a href="#RHS查询与LHS查询？-1" class="headerlink" title="RHS查询与LHS查询？"></a>RHS查询与LHS查询？</h1><p>LHS查询：查找变量的容器本身（a=1）<br>RHS查询： 查找变量的值（console.log(a)）</p><pre><code>function foo(a){    console.log(a)}foo(2) //RHS查询// 将2作为参数传给foo函数，给参数a隐式地分配值时进行了一次LHS查询</code></pre><h1 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在作用域中找不到变量  </p><p>在作用域中找变量  </p><p>总结：<br>不成功的RHS引用抛ReferenceError</p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2018/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo + github 博客搭建指南</title>
      <link>http://qiansr.github.io/2018/01/14/Hexo%20+%20github%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</link>
      <guid>http://qiansr.github.io/2018/01/14/Hexo%20+%20github%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Sat, 13 Jan 2018 18:18:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;用hexo-github-搭建博客&quot;&gt;&lt;a href=&quot;#用hexo-github-搭建博客&quot; class=&quot;headerlink&quot; title=&quot;用hexo + github 搭建博客&quot;&gt;&lt;/a&gt;用hexo + github 搭建博客&lt;/h1&gt;&lt;p&gt;早在几年以前
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="用hexo-github-搭建博客"><a href="#用hexo-github-搭建博客" class="headerlink" title="用hexo + github 搭建博客"></a>用hexo + github 搭建博客</h1><p>早在几年以前用hexo 搭建过一个博客系统部署到github上，但是一直没有用起来，平时都是习惯用mac 的备忘录记录一些东西。现在离职状态中准备找下个东家了，发现没个博客还是有些不妥，所以开始重新又弄了弄hexo，顺便也记录一下过程。</p><h2 id="新建github仓库"><a href="#新建github仓库" class="headerlink" title="新建github仓库"></a>新建github仓库</h2><p>仓库命名要同github账户名关连，格式如下:<br>仓库名：<code>qiansr.github.io</code><br>其中qiansr是我的github账户名，qiansr.github.io这个仓库名也将是你项目的访问域名。注意“<code>.github.io</code>” 不能省略。</p><h2 id="ssh密钥创建"><a href="#ssh密钥创建" class="headerlink" title="ssh密钥创建"></a>ssh密钥创建</h2><figure class="highlight plain"><figcaption><span>～／.ssh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/.ssh                                  //检查是否存在.pub</span><br><span class="line">ssh-keygen -t rss -C “youremail@email.com”    //创建钥匙对</span><br><span class="line">3. pbcopy &lt; id_rsa.pub                       //拷贝公钥到剪切板:</span><br><span class="line">4. 添加到gitlab或github账户</span><br></pre></td></tr></table></figure><h2 id="添加密钥"><a href="#添加密钥" class="headerlink" title="添加密钥"></a>添加密钥</h2><p>进入仓库=&gt;Settings=&gt;Deploy keys<br>Title:blog<br>Key:粘贴密钥<br>=&gt; add key</p><p><strong>测试添加ssh是否成功：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">==&gt; 如果看到下面这句：Hi后面是你的用户名，就说明成功了</span><br><span class="line">Hi qiansr! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ～</span><br><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><p>创建项目：<br><figure class="highlight plain"><figcaption><span>init blog</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ./blog</span><br><span class="line"></span><br><span class="line">vim package.json</span><br><span class="line">A</span><br></pre></td></tr></table></figure></p><p>修改package.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;3.4.4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.2.0&quot;,</span><br><span class="line">    &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">    &quot;hexo-generator-feed&quot;: &quot;^1.2.2&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-generator-sitemap&quot;: &quot;^1.2.0&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.2.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ESC + :wq           //保存退出vim</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>本地运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">==&gt;</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p><p>在游览器中输入 <a href="http://localhost:4000/就可以看到你的博客了。" target="_blank" rel="noopener">http://localhost:4000/就可以看到你的博客了。</a></p><h2 id="配置hexo与github连接"><a href="#配置hexo与github连接" class="headerlink" title="配置hexo与github连接"></a>配置hexo与github连接</h2><p>打开_config.yml文件<br>修改deploy值，在最后一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/qiansr/qiansr.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>把qiansr替换成你的github用户名</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h2 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot;         #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot;    #新建页面</span><br><span class="line">hexo generate               #生成静态页面至public目录</span><br><span class="line">hexo server                 #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy                 #将.deploy目录部署到GitHub</span><br><span class="line">hexo help                   #查看帮助</span><br><span class="line">hexo version                #查看Hexo的版本</span><br></pre></td></tr></table></figure><h2 id="主题资源"><a href="#主题资源" class="headerlink" title="主题资源"></a>主题资源</h2><p><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">https://www.zhihu.com/question/24422335</a></p><h1 id="hexo-完善博客设置"><a href="#hexo-完善博客设置" class="headerlink" title="hexo 完善博客设置"></a>hexo 完善博客设置</h1><h3 id="Hexo博客绑定域名"><a href="#Hexo博客绑定域名" class="headerlink" title="Hexo博客绑定域名"></a>Hexo博客绑定域名</h3><p>参阅《hexo搭建的Github博客绑定域名》：<a href="http://www.jianshu.com/p/cea41e5c9b2a" target="_blank" rel="noopener">http://www.jianshu.com/p/cea41e5c9b2a</a></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br><span class="line">cd 根目录</span><br><span class="line">vim _config.yml</span><br><span class="line">找到theme属性，将其由landscape（默认主题）改为next。</span><br></pre></td></tr></table></figure><h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><p>这里我选用的是NexT主题<br>在NexT主题目录下同样有一个名为_config.yml文件，称为主题配置文件，在其中找到scheme属性，<br>NexT主题默认使用Muse模式，你可根据自己的喜好，选择其中一种模式。</p><h3 id="预览摘要"><a href="#预览摘要" class="headerlink" title="预览摘要"></a>预览摘要</h3><p>主题配置文件 auto_excerpt 属性：<br>enable: true<br>length: 150 #想要预览到的字数<br>￼</p><h3 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h3><p>目前多说以挂，所以我们这里添加的是友言的评论系统<br>注册友言账号，获取uid  （后台管理 =&gt; 用户ID）<br>打开主题配置文件 找到youyan_uid属性设置uid  </p><h2 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">微信收款二维码     教程: https://jingyan.baidu.com/article/b907e627b641b646e6891c6b.html  </span><br><span class="line">支付宝收款二维码    教程: http://blog.csdn.net/china8848/article/details/53504223  </span><br><span class="line"></span><br><span class="line">二维码图片放到NexT根目录`/source/images/`文件夹下  </span><br><span class="line">开启打赏功能主题配置文件，在其最后添加打赏的配置信息:</span><br><span class="line"></span><br><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！  </span><br><span class="line">wechatpay: 图片链接或图片相对路径  </span><br><span class="line">alipay: 图片链接或图片相对路径</span><br></pre></td></tr></table></figure><h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><p>主题配置文件 sidebar的display属性，display属性有四种显示模式：<br>post    // 默认显示方式<br>always  // 一直显示<br>hide    // 初始隐藏<br>remove  // 移除侧边栏</p><h3 id="添加菜单选项（菜单栏标签页）"><a href="#添加菜单选项（菜单栏标签页）" class="headerlink" title="添加菜单选项（菜单栏标签页）"></a>添加菜单选项（菜单栏标签页）</h3><p>默认菜单只有首页、归档、关于三个选项，主题配置文件找到menu属性，通过去掉categories、 tags、about的的注释新增标签页：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 命令行执行下列命令来添加分类页面</span><br><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page “tags”</span><br><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure></p><p>会在source 目录下创建的三个目录和各自的index.md文件<br>打开index.md中在头部分别添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: “categories”</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure></p><p>当要为某一篇文章添加标签，在tags中添加，添加分类在categories中添加。</p><h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><p>搜索的功能源于第三方服务——Algolia，接下来看看配置的步骤：注册Algolia官网，创建一个Index。<br>安装Hexo Algolia</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-algolia</span><br></pre></td></tr></table></figure><p>如果安装失败，找到package.json文件，修改其中的hexo-algolia属性值为^0.2.0，然后再重新安装<br>获取Key，修改站点配置Algolia官网的Dashboard =&gt; API Keys<br>编辑站点配置文件，在文件内容最后添加如下信息，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ApplicationID: ‘’</span><br><span class="line">Search-Only API Key: </span><br><span class="line">Admin API Key: </span><br><span class="line">indexName: </span><br><span class="line">#其中apiKey就是Search-Only API Key：</span><br></pre></td></tr></table></figure></p><p>更新Index配置好Key后，在Hexo根目录执行hexo algolia来更新Index<br>启用配置搜索功能修改主题配置文件，在其中找到algolia_search属性，将其enable子属性改为true，然后再看其labels子属性，修改相应的提示文本，使之更加适合自己的风格  </p><div color:red>（本人博客配置完了，发现搜索不到任何内容，目前不想再捣鼓了，有人遇到类似问题如果解决了麻烦贴一下解决办法）</div><h3 id="阅读次数"><a href="#阅读次数" class="headerlink" title="阅读次数"></a>阅读次数</h3><p>阅读次数统计是基于第三方服务——LeanCloud实现的，其配置详情如下：<br>创建LeanCloud账号进入LeanCloud官网完成注册:创建应用选择开发版 =&gt; 存储 =&gt;<br>创建Class名称为Counter =&gt; 选择无限制选项<br>配置Key:单击应用Key，可以看到应用的App ID和App Key。主题配置文件中，在文件中找到leancloud_visitors属性，将enable设置为true，然后将之前复制的ID和Key粘贴到相应的属性中。</p><h3 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h3><p>在主题配置文件中找到<code>social</code>属性，在其下方添加社交链接，其格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github：链接</span><br></pre></td></tr></table></figure></p><p><strong>添加链接图标</strong><br>主题配置文件中找到<code>social_icons</code>，修改其状态值为true，然后配置对应链接的图标，其格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github: Font Awesome中的图标的名字（区分大小写）</span><br><span class="line">Font Awesome平台没有的图标，会显示默认。</span><br></pre></td></tr></table></figure></p><p><strong>友情链接</strong><br>主题配置文件中找到links属性，修改<code>links_title</code>属性的值为“友情链接”，然后添加上好友的友链名称和地址，其格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名称: 链接</span><br></pre></td></tr></table></figure></p><h3 id="语言设定"><a href="#语言设定" class="headerlink" title="语言设定"></a>语言设定</h3><p>在站点根目录下修改配置文件_cofig.yml中的language为zh-Hans（简体中文）</p><h3 id="增改菜选项"><a href="#增改菜选项" class="headerlink" title="增改菜选项"></a>增改菜选项</h3><p>修改在主题目录下配置文件_cofig.yml中的menu，增添一个something<br>修改主题目录下的languages文件中对应的zh-hans.yml文档<br>设置菜单项图标，对应的字段是menu_icons。格式为item name：icon name，其中item name与所配置的菜单名字对应，icon name是Font Awesome图标的名字。</p><h3 id="设置侧栏位置"><a href="#设置侧栏位置" class="headerlink" title="设置侧栏位置"></a>设置侧栏位置</h3><p>修改主题目录下sidebar的position值</p><h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下）</p><h3 id="设置文章代码主题"><a href="#设置文章代码主题" class="headerlink" title="设置文章代码主题"></a>设置文章代码主题</h3><p>在主题目录下修改配置文件highlight_theme，默认值为nomal。可以设置为night  </p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT主题官方文档的链接</a></p><h1 id="使用-GitHub-Issues-搭建评论系统"><a href="#使用-GitHub-Issues-搭建评论系统" class="headerlink" title="使用 GitHub Issues 搭建评论系统"></a>使用 GitHub Issues 搭建评论系统</h1><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p><strong>注册 OAuth Application</strong><br>点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名）。<br>你会得到一个 client ID 和一个 client secret，这个将被用于之后的用户登录。<br><strong>引入 Gitment</strong><br>将下面的代码添加到你的页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;</span><br><span class="line">&lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var gitment = new Gitment(&#123;</span><br><span class="line">  id: &apos;页面 ID&apos;, // 可选。默认为 location.href</span><br><span class="line">  owner: &apos;你的 GitHub ID&apos;,</span><br><span class="line">  repo: &apos;存储评论的 repo&apos;,</span><br><span class="line">  oauth: &#123;</span><br><span class="line">    client_id: &apos;你的 client ID&apos;,</span><br><span class="line">    client_secret: &apos;你的 client secret&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">gitment.render(&apos;container&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>注意，上述代码引用的 Gitment<br>将会随着开发变动。如果你希望始终使用最新的界面与特性即可引入上述代码。<br>如果你希望引用确定版本的 Gitment，则应该使用 npm 进行安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save gitment</span><br></pre></td></tr></table></figure></p><p>关于构造函数中的更多可用参数请查看 Gitment Options</p><p><strong>初始化评论</strong><br>页面发布后，你需要访问页面并使用你的 GitHub 账号登录（请确保你的账号是第二步所填 repo 的 owner），点击初始化按钮。之后其他用户即可在该页面发表评论。</p><p><strong>自定义</strong><br>Gitment 很容易进行自定义，你可以写一份自定义的 CSS 或者使用一个新的主题。（主题可以改变 DOM 结构而自定义 CSS 不能）<br>比如你可以通过自定义主题将评论框放在评论列表前面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const myTheme = &#123;</span><br><span class="line">  render(state, instance) &#123;</span><br><span class="line">    const container = document.createElement(&apos;div&apos;)</span><br><span class="line">    container.lang = &quot;en-US&quot;</span><br><span class="line">    container.className = &apos;gitment-container gitment-root-container&apos;</span><br><span class="line">    container.appendChild(instance.renderHeader(state, instance))</span><br><span class="line">    container.appendChild(instance.renderEditor(state, instance))</span><br><span class="line">    container.appendChild(instance.renderComments(state, instance))</span><br><span class="line">    container.appendChild(instance.renderFooter(state, instance))</span><br><span class="line">    return container</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gitment = new Gitment(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  theme: myTheme,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitment.render(&apos;container&apos;)</span><br></pre></td></tr></table></figure></p><p>更多自定义内容请查看文档。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p><strong>语言问题</strong><br>考虑到 GitHub 本身使用英文，而本项目面向用户均为 GitHub 用户，所以作者没有提供中文支持的打算。实在有需求的可以通过自定义主题支持中文。</p><p>￼</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p><strong>问：本地部署成功了，也能预览效果，但执行hexo d -g后，使用 username.github.io 访问，无效果</strong><br>答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了。如果没有成功，则查看你的本地git仓库的用户名和邮箱l设置是否和github账号邮箱一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.emial</span><br><span class="line">git config user.name</span><br></pre></td></tr></table></figure></p><p>如果不一致要改为一致才行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.emial github邮箱</span><br><span class="line">git config user.name github账户名</span><br></pre></td></tr></table></figure></p><p>重新执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p><p>再检查是否成功。</p><p><strong>问：多设备维护？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">新建hexo分支  </span><br><span class="line">git remote add origin https://github.com/用户名/仓库名.git</span><br><span class="line">git checkout -b 分支名</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line"></span><br><span class="line">#其他设备上clone下Github上新建的分支的文件到本地  </span><br><span class="line">#在另一台设备上使用git指令下载Github新建分支上的文件:  </span><br><span class="line"></span><br><span class="line">git clone -b 分支名 https://github.com/用户名/仓库名.git</span><br><span class="line">npm install  </span><br><span class="line">同步项目源文件到Github</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;&quot;</span><br><span class="line">// 先拉原来Github分支上的源文件到本地，进行合并</span><br><span class="line">git pull origin 分支名</span><br><span class="line">// 比较解决前后版本冲突后，push源文件到Github的分支</span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure></p><p><strong>运行hexo g报错?</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something&apos;s wrong...</span><br></pre></td></tr></table></figure></p><p>这个问题我出现多次，是由于你写的markdowan语法有问题。检查对比语法看看是否正确，例如使用了代码中的符合<br><a href="https://segmentfault.com/q/1010000003987383" target="_blank" rel="noopener">https://segmentfault.com/q/1010000003987383</a></p><p>替换markdown 默认渲染引擎<br>npm un hexo-renderer-marked –save<br>npm i hexo-renderer-markdown-it –save</p><p> 推荐资源<br> <a href="https://www.0101tx.com/categories/Hexo/" target="_blank" rel="noopener">https://www.0101tx.com/categories/Hexo/</a></p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2018/01/14/Hexo%20+%20github%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java学习笔记</title>
      <link>http://qiansr.github.io/2018/01/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>http://qiansr.github.io/2018/01/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 10 Jan 2018 17:01:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;8种基本数据类型b&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><strong>8种基本数据类型b</strong></p><table><thead><tr><th>数据类型</th><th>type</th><th>包装类</th></tr></thead><tbody><tr><td>基本类型</td><td>byte</td><td>java.lang.Byte</td></tr><tr><td>基本类型</td><td>short</td><td>java.lang.Short</td></tr><tr><td>基本类型</td><td>int</td><td>java.lang.Integer</td></tr><tr><td>基本类型</td><td>long</td><td>java.lang.Long</td></tr><tr><td>基本类型</td><td>float</td><td>java.lang.Float</td></tr><tr><td>基本类型</td><td>double</td><td>java.lang.Double</td></tr><tr><td>基本类型</td><td>char</td><td>java.lang.Character</td></tr><tr><td>基本类型</td><td>boolean</td><td>java.lang.Boolean</td></tr></tbody></table><p>引用类型:   Class,Collection集合类<br>自定义类</p><h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ol><li>抽象类<br>包含一个抽象方法的类就是抽象类</li><li><p>抽象方法<br>声明而未被实现的方法，抽象方法必须使用abstract关键词字声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class People &#123;  //关键词abstract，声明该类为抽象类</span><br><span class="line">    public int age;</span><br><span class="line">    public void Num() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract Name(); //声明该方法为抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类被子类继承，子类（如果不是抽象类）必须重写抽象类中的所有抽象方法</p></li><li>抽象类不能被直接实例化，要通过其子类进行实例化</li><li>只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。</li><li>子类中的抽象方法不能与父类的抽象方法同名。</li><li>abstract不能与final并列修饰同一个类。</li><li>abstract 不能与private、static、final或native并列修饰同一个方法。</li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ol><li>接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或者函数。在Java中它是对行为的抽象。</li><li>接口中可以定义 变量和方法。</li><li>接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误）。</li><li>接口中的方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），</li><li>接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。</li></ol><p><strong>接口的格式</strong></p><pre><code>interface interfaceName{    全局常量    抽象方法}class A  implements Interface1,Interface2,[....]{     ...  接口的实现使用关键字implements，而且接口是可以多实现的}class A extends Abs implements Inter1,Inter2{ //Abs是一个抽象类    ...一个类可以同时继承抽象类和接口}interface Inter implements Inter1,Inter2{ //Inter、Inter1、Inter2都为接口    ...接口能通过extends关键字继承多个接口}</code></pre><h2 id="抽象类和接口区别"><a href="#抽象类和接口区别" class="headerlink" title="抽象类和接口区别"></a>抽象类和接口区别</h2><h3 id="语法层次"><a href="#语法层次" class="headerlink" title="语法层次"></a>语法层次</h3><pre><code>public abstract class People {  //关键词abstract，声明该类为抽象类    void Num();　　　　　　    abstract void Name(); 　　　//声明该方法为抽象方法}Interface Person {　　void Num();　　void Name();}　</code></pre><p>抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，<br>但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。<br>在某种程度上来说，接口是抽象类的特殊化。对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。</p><h3 id="设计层次"><a href="#设计层次" class="headerlink" title="设计层次"></a>设计层次</h3><p>1、 抽象层次不同<br>抽象类是对类抽象。<br>接口是对行为的抽象。<br>抽象类是对整个类整体进行抽象，包括属性、行为。<br>接口却是对类局部（行为）进行抽象。</p><p>2、 跨域不同<br>抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可。但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p><p>3、 设计层次不同<br>抽象类是自下而上来设计的，我们要先知道子类才能抽象出父类。<br>接口不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。  </p><p>比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！<br>但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>抽象类的子类不能再继承其他的类,可以实现多个接口.因为java是单继承的.<br>如果说目前有一个类已经继承(extends)其他类了,如果这个时候又有一个父类出现,那么只能定义为他的父类为接口,不能定义为抽象类<br>抽象类中除了能定义抽象方法以外,也可以定义具体的方法,并且可以定义方法体内容.<br>接口中是不可以定义具体的方法实现,他只能允许你定义方法但是不能有任何方法体.<br>概念上的区别:<br>抽象类:如果一个类中没有包含足够的信息来描述一个具体的对象,这样的类就是抽象类。接口是一种特殊的抽象类，可以这么理解,接口是抽象类的一种特殊表现,有自己的一套规范约束在里面.<br>实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。</p><h3 id="门和警报的例子"><a href="#门和警报的例子" class="headerlink" title="门和警报的例子"></a>门和警报的例子</h3><p>门都有<code>open( )</code>和<code>close( )</code>两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念。</p><pre><code>abstract class Door {    public abstract void open();    public abstract void close();}or：interface Door {    public abstract void open();    public abstract void close();}</code></pre><p>给门延伸报警<code>alarm( )</code>的功能，那么该如何实现？</p><p><strong>放在抽象类里面：</strong><br>但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p><p><strong>放在接口里面：</strong><br>需要用到报警功能的类就需要实现这个接口中的<code>open( )</code>和<code>close( )</code>，也许这个类根本就不具备<code>open( )</code>和<code>close( )</code>这两个功能，比如火灾报警器。</p><p>从这里可以看出， Door的<code>open()</code>、<code>close()</code>和<code>alarm()</code>根本就属于两个不同范畴内的行为，<code>open()</code>和<code>close()</code>属于门本身固有的行为特性，而<code>alarm()</code>属于延伸的附加行为。</p><p><strong>最好的解决办法：</strong><br>单独将报警设计为一个接口，包含<code>alarm()</code>行为。<br>Door设计为单独的一个抽象类，包含open和close两种行为。<br>再设计一个报警门继承Door类和实现Alarm接口。</p><pre><code>interface Alram {    void alarm();}abstract class Door {    void open();    void close();}class AlarmDoor extends Door implements Alarm {    void oepn() {      //....    }    void close() {      //....    }    void alarm() {      //....    }}</code></pre><h2 id="java-中的字符串"><a href="#java-中的字符串" class="headerlink" title="java 中的字符串"></a>java 中的字符串</h2><p>Java中String、StringBuffer、StringBuilder和toString的介绍</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>1、字符串长度——length（）  </p><pre><code>String str = &quot;coder&quot;;  System.out.print(str.length());输出结果：5</code></pre><p>2、字符串转换数组——toCharArray（）</p><pre><code>String str = &quot;coder&quot;;char data[] = str.toCharArray(); //调用String类中toCharArray方法for (int i = 0; i &lt; data.length; i++){System.out.print(data[i]+&quot; &quot;); //加入空格，以示区分}输出结果：c o d e r</code></pre><p>3、从字符串中取出指定位置的字符——charAt()</p><pre><code>String str = &quot;coder&quot;;System.out.print(str.charAt(3));输出结果：e</code></pre><p>4、字符串与byte数组的转换——getBytes()</p><pre><code>String str = &quot;coder&quot;;byte bytes[] = str.getBytes();for (int i = 0; i &lt; bytes.length; i++){System.out.print(new String(bytes)+&quot;\t&quot;); //加入换行，以示区分}输出结果：codercodercodercodercoder</code></pre><p>5、过滤字符串中存在的字符——indexOf() </p><pre><code>String str = &quot;coder@163.com&quot;;System.out.print(str.indexOf(&quot;@&quot;));输出结果：5</code></pre><p>6、去掉字符串的前后空格——trim()</p><pre><code>String str = &quot; coder@163.com &quot;;System.out.print(str.trim());输出结果：coder</code></pre><p>7、从字符串中取出子字符串——subString()<br>8、大小写转换——toLowerCase()、toUpperCase()<br>9、判断字符串的开头结尾字符——endWith()、startWith()<br>10、替换String字符串中的一个字符——replace()</p><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p>1、认识StringBuffer:<br>缓冲区、本身也是操作字符串，但是与String不同，StringBuffer是可以更改的。StringBuffer也是一个操作类，所以必须通过实例化进行操作  </p><p>2、StringBuffer常用方法：</p><pre><code>append()insert()replace()indexOf()举例：StringBuffer str = new StringBuffer();str.append(&quot;coder&quot;);system.out.print(str.toString());输出结果：coder</code></pre><h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>1、认识StringBuilder:<br>一个可变的字符序列，该类被设计作用StringBuffer的一个简易替换，用在字符串缓冲区被单个线程所使用的时候。建议优先考虑该类，速度比StringBuffer要快<br>2、但是如果涉及到线程安全方面，建议使用StringBuffer<br>3、StringBuilder常用方法：</p><pre><code>append()insert()replace()indexOf()</code></pre><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><p>因为它是Object里面已经有了的方法，而所有类都是继承Object，所以“所有对象都有这个方法”。它通常只是为了方便输出，比如System.out.println(xx)，括号里面的“xx”如果不是String类型的话，就自动调用xx的toString()<br>方法。总而言之，它只是sun公司开发java的时候为了方便所有类的字符串操作而特意加入的一个方法。<br>举例：</p><pre><code>StringBuffer str = new StringBuffer();str.append(&quot;coder&quot;);system.out.print(str.toString());输出结果：coder</code></pre><h2 id="void关键字"><a href="#void关键字" class="headerlink" title="void关键字"></a>void关键字</h2><p>void就是空，在方法申明的时候表示该方法没有返回值<br>那么java中的void到底是什么类型呢？其实void也有对应的包装类<code>java.lang.Void</code>，不过我们无法直接对它们进行操作。 它继承于Object，如下：</p><pre><code>public final class Void extends Object {    /*     * The Void class cannot be instantiated.     */    private Void() {}}</code></pre><p>Void类和String类一样 被定义为final，所以不能扩展；另外，它的构造方法被私有化了所以不可实例化<br>Void类是一个不可实例化的占位符类，用来保存一个引用代表了Java关键字void的Class对象。</p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2018/01/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
