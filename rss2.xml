<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>神刀</title>
    <link>http://qiansr.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 18 Nov 2019 21:35:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Hello World</title>
      <link>http://qiansr.github.io/2019/11/19/hello-world/</link>
      <guid>http://qiansr.github.io/2019/11/19/hello-world/</guid>
      <pubDate>Mon, 18 Nov 2019 21:35:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Swig语法&quot;&gt;&lt;a href=&quot;#Swig语法&quot; class=&quot;headerlink&quot; title=&quot;Swig语法&quot;&gt;&lt;/a&gt;Swig语法&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;Every interaction is both precious and an 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Swig语法"><a href="#Swig语法" class="headerlink" title="Swig语法"></a>Swig语法</h2><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><blockquote><p>Every interaction is both precious and an opportunity to delight.<br>代码块</p></blockquote><h2 id="Swig语法-1"><a href="#Swig语法-1" class="headerlink" title="Swig语法"></a>Swig语法</h2><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><h2 id="Markdown语法-1"><a href="#Markdown语法-1" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><p>链接</p><a href="http://blog.fens.me" title="粉丝日志" target="_blank">粉丝日志</a><h2 id="Markdown语法-2"><a href="#Markdown语法-2" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><p><a href="http://blog.fens.me" target="_blank" rel="noopener">粉丝日志</a><br>图片，对于本地图片，需要在source目录下面新建一个目录images，然后把图片放到目录中。</p><h2 id="Swig语法-2"><a href="#Swig语法-2" class="headerlink" title="Swig语法"></a>Swig语法</h2><img src="/images/fens.me.png" width="400" height="600" title="这是一张图片"><h1 id="Markdown语法-3"><a href="#Markdown语法-3" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p><img src="/images/fens.me.png" alt="这是一张图片"></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$J_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$</p><hr><p><br><br><br></p><h1 id="完整的Swig语法"><a href="#完整的Swig语法" class="headerlink" title="完整的Swig语法"></a>完整的Swig语法</h1><p>通过下面的命令，就可以创建新文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\workspace\javascript\nodejs-hexo&gt;hexo new 新的开始</span><br><span class="line">[info] File created at D:\workspace\javascript\nodejs-hexo\source\_posts\新的开始.md</span><br></pre></td></tr></table></figure></p><p>感觉非常好。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><a href="http://blog.fens.me" title="粉丝日志" target="_blank">粉丝日志</a><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><img src="/images/fens.me.png" width="400" height="600" title="这是一张图片">]]></content:encoded>
      
      <comments>http://qiansr.github.io/2019/11/19/hello-world/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深入理解js系列一作用域是什么？</title>
      <link>http://qiansr.github.io/2018/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</link>
      <guid>http://qiansr.github.io/2018/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</guid>
      <pubDate>Mon, 05 Feb 2018 18:15:59 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;作用域是什么？&quot;&gt;&lt;a href=&quot;#作用域是什么？&quot; class=&quot;headerlink&quot; title=&quot;作用域是什么？&quot;&gt;&lt;/a&gt;作用域是什么？&lt;/h1&gt;&lt;h1 id=&quot;变量的作用域到底是如何在js中工作的？&quot;&gt;&lt;a href=&quot;#变量的作用域到底是如何在js
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="作用域是什么？"><a href="#作用域是什么？" class="headerlink" title="作用域是什么？"></a>作用域是什么？</h1><h1 id="变量的作用域到底是如何在js中工作的？"><a href="#变量的作用域到底是如何在js中工作的？" class="headerlink" title="变量的作用域到底是如何在js中工作的？"></a>变量的作用域到底是如何在js中工作的？</h1><h1 id="js是解释型语言而无法编译吗？"><a href="#js是解释型语言而无法编译吗？" class="headerlink" title="js是解释型语言而无法编译吗？"></a>js是解释型语言而无法编译吗？</h1><h1 id="什么是词法作用域？"><a href="#什么是词法作用域？" class="headerlink" title="什么是词法作用域？"></a>什么是词法作用域？</h1><h1 id="RHS查询与LHS查询？"><a href="#RHS查询与LHS查询？" class="headerlink" title="RHS查询与LHS查询？"></a>RHS查询与LHS查询？</h1><h1 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h1><p>js中的作用域可以理解为一套定义的规则，用来管理js引擎根据标识符名称进行变量查找，并确定当前执行代码对这些变量的访问权限。  </p><h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>要想深入理解js的作用域，我们必须得先知道js事实上是一门编译型语言（动态编译）– js引擎实际上是动态编译程序然后立即执行。与传统编译语言在构建前编译不同的是：js的编译发生在代码执行前（有时是执行中）的很短时间内，而且编译完通常就会马上执行它。另外，对比传统编译，js引擎在语法分析和代码生成阶段有特定的步骤对运行性能进行优化。这也是后面会谈到的<code>eval()</code>和<code>with()</code> 影响运行效率的原因。</p><h1 id="编译的三个步骤"><a href="#编译的三个步骤" class="headerlink" title="编译的三个步骤"></a>编译的三个步骤</h1><p>我们先来看看在传统编译语言中，一段源程序在执行前通常要经历的三个步骤，js作为一门动态编译语言，同样也会经历这些步骤：</p><ol><li>分词／词法分析（将源代码分解成词法单元）</li><li>解析／语法解析（转换为一棵由元素逐级嵌套组成代表程序语法的抽象语法树AST）</li><li>代码生成（将AST转换为可执行代码）</li></ol><p>在js中，js引擎负责整个js程序的编译和执行过程，编译器负责语法分析以及代码生成。</p><h1 id="js引擎做了什么？"><a href="#js引擎做了什么？" class="headerlink" title="js引擎做了什么？"></a>js引擎做了什么？</h1><p>当遇到<code>var a = 2</code>这段程序，js引擎做了什么？</p><ol><li>首先编译器会将这段代码分解成词法单元</li><li>编译器再将词法单元解析成一个树结构</li><li>编译器开始进行代码生成  <ol><li>遇到<code>var a</code>，查询作用域链是否有变量a：<br> 。 有a：跳过继续编译<br> 。 无a：在当前作用域声明一个变量a</li><li>为引擎生成运行时所需代码    </li></ol></li><li>引擎查询作用域链是否存在变量a：<br> 。存在：使用变量a执行赋值操作<br> 。不存在：抛出一个异常</li></ol><p>可以看出，变量的赋值操作会执行两个动作：<br>一个由编译器在编译时处理，另一个由引擎在运行时处理。  </p><h1 id="RHS查询与LHS查询？-1"><a href="#RHS查询与LHS查询？-1" class="headerlink" title="RHS查询与LHS查询？"></a>RHS查询与LHS查询？</h1><p>LHS查询：查找变量的容器本身（a=1）<br>RHS查询： 查找变量的值（console.log(a)）</p><pre><code>function foo(a){    console.log(a)}foo(2) //RHS查询// 将2作为参数传给foo函数，给参数a隐式地分配值时进行了一次LHS查询</code></pre><h1 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在作用域中找不到变量  </p><p>在作用域中找变量  </p><p>总结：<br>不成功的RHS引用抛ReferenceError</p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2018/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E7%B3%BB%E5%88%97%E4%B8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java学习笔记</title>
      <link>http://qiansr.github.io/2018/01/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>http://qiansr.github.io/2018/01/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Wed, 10 Jan 2018 17:01:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;8种基本数据类型b&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><strong>8种基本数据类型b</strong></p><table><thead><tr><th>数据类型</th><th>type</th><th>包装类</th></tr></thead><tbody><tr><td>基本类型</td><td>byte</td><td>java.lang.Byte</td></tr><tr><td>基本类型</td><td>short</td><td>java.lang.Short</td></tr><tr><td>基本类型</td><td>int</td><td>java.lang.Integer</td></tr><tr><td>基本类型</td><td>long</td><td>java.lang.Long</td></tr><tr><td>基本类型</td><td>float</td><td>java.lang.Float</td></tr><tr><td>基本类型</td><td>double</td><td>java.lang.Double</td></tr><tr><td>基本类型</td><td>char</td><td>java.lang.Character</td></tr><tr><td>基本类型</td><td>boolean</td><td>java.lang.Boolean</td></tr></tbody></table><p>引用类型:   Class,Collection集合类<br>自定义类</p><h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ol><li>抽象类<br>包含一个抽象方法的类就是抽象类</li><li><p>抽象方法<br>声明而未被实现的方法，抽象方法必须使用abstract关键词字声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class People &#123;  //关键词abstract，声明该类为抽象类</span><br><span class="line">    public int age;</span><br><span class="line">    public void Num() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract Name(); //声明该方法为抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类被子类继承，子类（如果不是抽象类）必须重写抽象类中的所有抽象方法</p></li><li>抽象类不能被直接实例化，要通过其子类进行实例化</li><li>只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。</li><li>子类中的抽象方法不能与父类的抽象方法同名。</li><li>abstract不能与final并列修饰同一个类。</li><li>abstract 不能与private、static、final或native并列修饰同一个方法。</li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ol><li>接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或者函数。在Java中它是对行为的抽象。</li><li>接口中可以定义 变量和方法。</li><li>接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误）。</li><li>接口中的方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），</li><li>接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。</li></ol><p><strong>接口的格式</strong></p><pre><code>interface interfaceName{    全局常量    抽象方法}class A  implements Interface1,Interface2,[....]{     ...  接口的实现使用关键字implements，而且接口是可以多实现的}class A extends Abs implements Inter1,Inter2{ //Abs是一个抽象类    ...一个类可以同时继承抽象类和接口}interface Inter implements Inter1,Inter2{ //Inter、Inter1、Inter2都为接口    ...接口能通过extends关键字继承多个接口}</code></pre><h2 id="抽象类和接口区别"><a href="#抽象类和接口区别" class="headerlink" title="抽象类和接口区别"></a>抽象类和接口区别</h2><h3 id="语法层次"><a href="#语法层次" class="headerlink" title="语法层次"></a>语法层次</h3><pre><code>public abstract class People {  //关键词abstract，声明该类为抽象类    void Num();　　　　　　    abstract void Name(); 　　　//声明该方法为抽象方法}Interface Person {　　void Num();　　void Name();}　</code></pre><p>抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，<br>但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。<br>在某种程度上来说，接口是抽象类的特殊化。对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。</p><h3 id="设计层次"><a href="#设计层次" class="headerlink" title="设计层次"></a>设计层次</h3><p>1、 抽象层次不同<br>抽象类是对类抽象。<br>接口是对行为的抽象。<br>抽象类是对整个类整体进行抽象，包括属性、行为。<br>接口却是对类局部（行为）进行抽象。</p><p>2、 跨域不同<br>抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可。但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。</p><p>3、 设计层次不同<br>抽象类是自下而上来设计的，我们要先知道子类才能抽象出父类。<br>接口不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。  </p><p>比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！<br>但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>抽象类的子类不能再继承其他的类,可以实现多个接口.因为java是单继承的.<br>如果说目前有一个类已经继承(extends)其他类了,如果这个时候又有一个父类出现,那么只能定义为他的父类为接口,不能定义为抽象类<br>抽象类中除了能定义抽象方法以外,也可以定义具体的方法,并且可以定义方法体内容.<br>接口中是不可以定义具体的方法实现,他只能允许你定义方法但是不能有任何方法体.<br>概念上的区别:<br>抽象类:如果一个类中没有包含足够的信息来描述一个具体的对象,这样的类就是抽象类。接口是一种特殊的抽象类，可以这么理解,接口是抽象类的一种特殊表现,有自己的一套规范约束在里面.<br>实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。</p><h3 id="门和警报的例子"><a href="#门和警报的例子" class="headerlink" title="门和警报的例子"></a>门和警报的例子</h3><p>门都有<code>open( )</code>和<code>close( )</code>两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念。</p><pre><code>abstract class Door {    public abstract void open();    public abstract void close();}or：interface Door {    public abstract void open();    public abstract void close();}</code></pre><p>给门延伸报警<code>alarm( )</code>的功能，那么该如何实现？</p><p><strong>放在抽象类里面：</strong><br>但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p><p><strong>放在接口里面：</strong><br>需要用到报警功能的类就需要实现这个接口中的<code>open( )</code>和<code>close( )</code>，也许这个类根本就不具备<code>open( )</code>和<code>close( )</code>这两个功能，比如火灾报警器。</p><p>从这里可以看出， Door的<code>open()</code>、<code>close()</code>和<code>alarm()</code>根本就属于两个不同范畴内的行为，<code>open()</code>和<code>close()</code>属于门本身固有的行为特性，而<code>alarm()</code>属于延伸的附加行为。</p><p><strong>最好的解决办法：</strong><br>单独将报警设计为一个接口，包含<code>alarm()</code>行为。<br>Door设计为单独的一个抽象类，包含open和close两种行为。<br>再设计一个报警门继承Door类和实现Alarm接口。</p><pre><code>interface Alram {    void alarm();}abstract class Door {    void open();    void close();}class AlarmDoor extends Door implements Alarm {    void oepn() {      //....    }    void close() {      //....    }    void alarm() {      //....    }}</code></pre><h2 id="java-中的字符串"><a href="#java-中的字符串" class="headerlink" title="java 中的字符串"></a>java 中的字符串</h2><p>Java中String、StringBuffer、StringBuilder和toString的介绍</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>1、字符串长度——length（）  </p><pre><code>String str = &quot;coder&quot;;  System.out.print(str.length());输出结果：5</code></pre><p>2、字符串转换数组——toCharArray（）</p><pre><code>String str = &quot;coder&quot;;char data[] = str.toCharArray(); //调用String类中toCharArray方法for (int i = 0; i &lt; data.length; i++){System.out.print(data[i]+&quot; &quot;); //加入空格，以示区分}输出结果：c o d e r</code></pre><p>3、从字符串中取出指定位置的字符——charAt()</p><pre><code>String str = &quot;coder&quot;;System.out.print(str.charAt(3));输出结果：e</code></pre><p>4、字符串与byte数组的转换——getBytes()</p><pre><code>String str = &quot;coder&quot;;byte bytes[] = str.getBytes();for (int i = 0; i &lt; bytes.length; i++){System.out.print(new String(bytes)+&quot;\t&quot;); //加入换行，以示区分}输出结果：codercodercodercodercoder</code></pre><p>5、过滤字符串中存在的字符——indexOf() </p><pre><code>String str = &quot;coder@163.com&quot;;System.out.print(str.indexOf(&quot;@&quot;));输出结果：5</code></pre><p>6、去掉字符串的前后空格——trim()</p><pre><code>String str = &quot; coder@163.com &quot;;System.out.print(str.trim());输出结果：coder</code></pre><p>7、从字符串中取出子字符串——subString()<br>8、大小写转换——toLowerCase()、toUpperCase()<br>9、判断字符串的开头结尾字符——endWith()、startWith()<br>10、替换String字符串中的一个字符——replace()</p><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p>1、认识StringBuffer:<br>缓冲区、本身也是操作字符串，但是与String不同，StringBuffer是可以更改的。StringBuffer也是一个操作类，所以必须通过实例化进行操作  </p><p>2、StringBuffer常用方法：</p><pre><code>append()insert()replace()indexOf()举例：StringBuffer str = new StringBuffer();str.append(&quot;coder&quot;);system.out.print(str.toString());输出结果：coder</code></pre><h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>1、认识StringBuilder:<br>一个可变的字符序列，该类被设计作用StringBuffer的一个简易替换，用在字符串缓冲区被单个线程所使用的时候。建议优先考虑该类，速度比StringBuffer要快<br>2、但是如果涉及到线程安全方面，建议使用StringBuffer<br>3、StringBuilder常用方法：</p><pre><code>append()insert()replace()indexOf()</code></pre><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><p>因为它是Object里面已经有了的方法，而所有类都是继承Object，所以“所有对象都有这个方法”。它通常只是为了方便输出，比如System.out.println(xx)，括号里面的“xx”如果不是String类型的话，就自动调用xx的toString()<br>方法。总而言之，它只是sun公司开发java的时候为了方便所有类的字符串操作而特意加入的一个方法。<br>举例：</p><pre><code>StringBuffer str = new StringBuffer();str.append(&quot;coder&quot;);system.out.print(str.toString());输出结果：coder</code></pre><h2 id="void关键字"><a href="#void关键字" class="headerlink" title="void关键字"></a>void关键字</h2><p>void就是空，在方法申明的时候表示该方法没有返回值<br>那么java中的void到底是什么类型呢？其实void也有对应的包装类<code>java.lang.Void</code>，不过我们无法直接对它们进行操作。 它继承于Object，如下：</p><pre><code>public final class Void extends Object {    /*     * The Void class cannot be instantiated.     */    private Void() {}}</code></pre><p>Void类和String类一样 被定义为final，所以不能扩展；另外，它的构造方法被私有化了所以不可实例化<br>Void类是一个不可实例化的占位符类，用来保存一个引用代表了Java关键字void的Class对象。</p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2018/01/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Lisp学习指南</title>
      <link>http://qiansr.github.io/2017/12/10/lisp%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</link>
      <guid>http://qiansr.github.io/2017/12/10/lisp%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Sun, 10 Dec 2017 03:08:12 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h1&gt;&lt;h2 id=&quot;开发环境：&quot;&gt;&lt;a href=&quot;#开发环境：&quot; class=&quot;headerlink&quot; title=&quot;开发环境：&quot;&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><h2 id="开发环境："><a href="#开发环境：" class="headerlink" title="开发环境："></a>开发环境：</h2><p>SBCL<br>Emacs<br>Slime：在emacs里面帮助进行common lisp开发的扩展<br>quicklisp：Common Lisp的包管理工具</p><h2 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h2><h3 id="安装emacs"><a href="#安装emacs" class="headerlink" title="安装emacs"></a>安装emacs</h3><p>这个不用多讲了。从GNU的网站能下载到不同平台的版本。</p><h3 id="安装SBCL"><a href="#安装SBCL" class="headerlink" title="安装SBCL"></a>安装SBCL</h3><pre><code>brew install sbcl       （不支持左右箭头移动光标. 安装rlwrap支持）brew install rlwrap   （命令行输入交互增强工具, 支持方向键和历史命令）rlwrap sbcl        （启动sbcl命令）</code></pre><p>sbcl被安装到/usr/local/bin目录中(记住此地址，后面配置有用)</p><h3 id="安装quicklisp"><a href="#安装quicklisp" class="headerlink" title="安装quicklisp"></a>安装quicklisp</h3><pre><code>$ curl -O http://beta.quicklisp.org/quicklisp.lisp$ sbcl --load quicklisp.lisp(quicklisp-quickstart:install)(ql:add-to-init-file)(ql:quickload &quot;quicklisp-slime-helper&quot;)</code></pre><p>安装教程：<a href="http://www.quicklisp.org/beta/#installation" target="_blank" rel="noopener">http://www.quicklisp.org/beta/#installation</a><br>查找可用的包的信息，可以到cliki上去搜。</p><h3 id="安装slime"><a href="#安装slime" class="headerlink" title="安装slime"></a>安装slime</h3><p>在sbcl里面，运行：</p><pre><code>(ql:quickload &quot;quicklisp-slime-helper&quot;)  </code></pre><p>根据提示修改Emacs的配置文件。  </p><pre><code>cd ~/ &amp;&amp; vi .emacs添加下面两句(load (expand-file-name &quot;~/quicklisp/slime-helper.el&quot;))(setq inferior-lisp-program “/usr/local/bin/sbcl”)  ;你的sbcl路径  </code></pre><p>或者下载slime,地址 <a href="http://common-lisp.net/project/slime/#downloading" target="_blank" rel="noopener">http://common-lisp.net/project/slime/#downloading</a><br>把slime文件夹copy到了~/.emacs.d/目录中<br>配置.emacs配置文件：</p><pre><code>(setq inferior-lisp-program &quot;/usr/local/bin/sbcl&quot;)  (add-to-list &apos;load-path &quot;~/.emacs.d/slime/&quot;)  (require &apos;slime)  (slime-setup)  </code></pre><p>做完上面的步骤以后，打开emacs，按M-x，输入slime<br>这篇文章也有助于了解Slime: <a href="http://www.open-open.com/lib/view/open1400054028504.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1400054028504.html</a></p><h1 id="Lisp-基础语法"><a href="#Lisp-基础语法" class="headerlink" title="Lisp 基础语法"></a>Lisp 基础语法</h1><h2 id="表达式："><a href="#表达式：" class="headerlink" title="表达式："></a>表达式：</h2><p>表达式或是一个原子，或是一个由零个或多个表达式组成的表(list)。<br>表达式之间用空格分开，放入一对括号中。<br>在算术中，表达式 1 + 1 得出值2。<br>Lisp表达式也有值，如果表达式e得出 值v，我们说e返回v。<br>如果一个表达式是表，我们称第一个元素为操作符，其余的元素为自变量。<br>七个原始操作符：quote，atom，eq，car，cdr，cons，cond  </p><p>通过引 用(quote)一个表,我们避免它被求值. 一个未被引用的表作为自变量传给象<br>atom这样的操作符将被视为代码:</p><pre><code>(atom (atom &apos;a))=&gt; T</code></pre><p>反之一个被引用的表仅被视为表, 在此例中就是有两个元素的表:</p><pre><code>(atom &apos;(atom &apos;a))=&gt; NIL</code></pre><h2 id="表与列表操作"><a href="#表与列表操作" class="headerlink" title="表与列表操作"></a>表与列表操作</h2><p>Lisp的全名叫“表处理语言”，LISt Procesor 。简单说来，用小括号括起来的表达式式就叫表。而表里面的东西，就是原子，表里不仅可以包含原子，也可以包含另一个表。也就是说表可以嵌套。最小的表就是空表 ( )。<br>在lisp中程序和数据都是用 表 来表示。<br>在lisp中 T 表示逻辑真；NIL表示逻辑假，同时也是空表。<br>Lisp会对所有的表求值，如果想使用表本身 (作为数据), 需在表前加 ‘ 操作符 (单引号)。</p><pre><code>&apos;(+ 1 2)               =&gt; (+ 1 2)</code></pre><p>这次解译器不对这个表其求值了，而是原来这个表本身。<br>在所有的表中，第一个原子总是函数，代表操作、指令、命令。而之后原子（或表）是参数，意即对操作的说明</p><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><p>car:                 取出表的第一个元素并返回该元素（同first）<br>last:                返回最后一个元素的表<br>cdr:                返回除第一个元素之外的表（同rest）</p><pre><code>(car &apos;((1 2) 3))       =&gt;（1 2）(cdr &apos;(+ 1 2 3))        =&gt;  (1 2 3)       #取出函数的参数(cdr &apos;(1))              =&gt;  NIL(cadr &apos;(1 2 3))         =&gt;  2           #等价(car (cdr (cdr &apos;(1 2 3))))</code></pre><p>其它:cadr    or    caddr</p><h3 id="构造表"><a href="#构造表" class="headerlink" title="构造表"></a>构造表</h3><p><strong>cons 函数</strong>:<br>连接一个元素与一个表，接受两个参数，参数顺序不可颠倒。第二个参数为列表时，才能返回一个列表。cons 的作用是将两棵树连接成一棵树。</p><pre><code>(cons 1 &apos;(2 3))                    =&gt; (1 2 3) (cons 2 3)                        =&gt; (2 . 3)  (cons 1 (cons 2 &apos;(3)))            =&gt; (1 2 3)     连接三个或以上的元素(cons 1 (cons 2 (cons 3 nil)))    =&gt; (1 2 3)(cons 3 nil)                    =&gt; (3)</code></pre><p><strong>为什么(cons 2 3) 返回 (2 . 3)呢？中间有一个 “.”呢？</strong></p><blockquote><p>这是因为表实际上是一个树（二叉树），在S表达式中， 二叉树表示为 (Left . Right)。<br>如果左支是表，成为形式：((List) . Right)<br>如果右支是表，表示为 (Left . (List)) ，此时点可以省略，写成(Left List)<br><code>&#39;(3 . (2 3))  =&gt; (3 2 3)</code><br>这就是为什么cdr操作符会取出除第一个外的所有元素，因为它实质是取二叉树的右支。</p></blockquote><p><strong>append 函数</strong>:<br>它会把最外一层括号去掉，然后连接</p><pre><code>(append &apos;(3 3) &apos;(4 4))          =&gt;  (3 3 4 4)  连接两个表(append &apos;((3)) &apos;(4 4))           =&gt;  ((3) 4 4)</code></pre><p><strong>list 函数</strong>:<br>list 函数将所有的参数放入一个表中并返回</p><pre><code>(list 1 1 1 1)                  =&gt;  (1 1 1 1)  返回包含所有参数的表(list &apos;(2 3) &apos;(2) 1 2)            =&gt;  ((2 3) (2) 1 2)</code></pre><p>构造函数 cons带有两个参数：一个原子和一个列表。cons 将该原子作为第一个元素添加到该列表。如果对 nil 调用 cons，Lisp 将 nil 作为空列表对待，并构建一个含一个元素的列表。append 连接两个列表。list 包含一个由所有参数组成的列表</p><h2 id="原子和值"><a href="#原子和值" class="headerlink" title="原子和值"></a>原子和值</h2><p><strong>原子</strong><br>可以是任何数或者字母排列。空表就是原子NIL。  </p><pre><code>&apos;sdf  =&gt; SDF       原子前面加一个引用符（单引号），返回这个原子本身</code></pre><p><strong>atom 运算符</strong><br>判断一个元素是不是原子  </p><pre><code>(atom &apos;a)        =&gt; T        a 是一个原子(atom &apos;(3))        =&gt; NIL    (3) 是一个列表而不是原子</code></pre><p><strong>setq 运算符</strong><br>绑定一个变量</p><pre><code>(setq a 5)         =&gt; 5a  =&gt; 5</code></pre><p>setq的意义就是赋值并且将此值返回。就是说表达式(setq a 5)的值是5<br>我们可以接着</p><pre><code>(setq a 6)        =&gt; 6(cons a &apos;(3))          =&gt; (6 3)(setq a &apos;b)        =&gt; B(cons a &apos;(3))        =&gt; (B 3)(setq a &apos;(1 2 3))    =&gt; (1 2 3)(cdr a)            =&gt; (2 3)</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><pre><code>(defun 函数名 (参数列表)  (first (rest lst))；执行体)</code></pre><p>defun 用来定义函数。第一个参数是函数名，第二个参数是参数列表，第三个参数是希望执行的代码<br>Lisp 所有代码都表述为列表。可以像操纵其他任何数据一样操纵应用程序。</p><h3 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h3><p><strong>atom 函数</strong><br>用来判断一个表达式是不是原子</p><pre><code>(atom (+ 1 1))        =&gt; T(atom &apos;(3))        =&gt; NIL</code></pre><p>因为2是原子，而（3）是个表。</p><p><strong>null 函数</strong><br>NULL函数用来判断表达式的值是不是NIL。</p><pre><code>(null nil)            =&gt; T(null (car &apos;(3)))        =&gt; NIL</code></pre><p><strong>equal 函数</strong><br>用来判断两个表达式的值是否完全相等  </p><pre><code>(equal &apos;s &apos;s)        =&gt; T(equal &apos;(s) &apos;(s))        =&gt; T</code></pre><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>在 Lisp 中，由于函数和列表没有任何区别，高阶函数也就非常简单。<br>高阶函数的最常见用法或许是 lambda 表达式，这是闭包的 Lisp 版。lambda 函数是用于将高阶函数传入 Lisp 函数的函数定义。<br>例如，下列lambda 表达式计算了两个整数的和：<br>(setf total ‘(lambda (a b) (+ a b)))<br>(LAMBDA (A B) (+ A B))<br> total<br>(LAMBDA (A B) (+ A B))<br>(apply total ‘(101 102))<br>203</p><p>如果使用过高阶函数或闭包，那么可能更容易理解清单 10 中的代码。第一行代码定义了一个 lambda   </p><p>表达式并将其和 total 符号绑定到一起。第二行代码仅显示了这个和 total 绑定到一起的 lambda 表达式。最终，最后一个表达式对包含 (101 102) 的列表应用这个 lambda 表达式。<br>高阶函数提供比面向对象概念更高层次的抽象。可以用它们来更简洁清晰地表达想法。编程的至高境界就是在不牺牲可读性或性能的前提下，用更少的代码提供更强大更灵活的功能。高阶函数能实现所有这些要求。  </p><p>Lisp 还有两种类型的高阶函数。其中功能最强大的可能是宏。宏为后面的执行定义 Lisp 对象。可以将宏看作代码模板。请参考清单 11 中的示例：<br>清单 11. 宏</p><pre><code>(defmacro times_two (x) (* 2 x))TIMES_TWO(setf a 4)4(times_two a)8</code></pre><p>这个示例应该分为两个阶段进行阅读。第一次赋值定义了宏 times_two。在第二个阶段（称为宏扩展）中，在对 a 求值之前，将 a 扩展为 (* 2 a)。该模板中这项延迟求值方式使宏的功能非常强大。Lisp 语言本身的许多功能都是基于宏的。</p><h2 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h2><p><strong>Cond 函数：</strong></p><pre><code>(cond 分支列表1 分支列表2 分支列表3 ... )</code></pre><p>分支列表的构成： (条件p 值e)<br>Cond 将对每一个“条件p”求值，如果为NIL，就接着求下一个，如果为真，就返回相应的“值e”，如果没有一个真值，cond操作符返回nil。  </p><p><strong>if 函数：</strong></p><pre><code>(if 判断表达式 真值时的返回值 假值时的返回值)</code></pre><p>eg：计算两个整数中的最大值</p><pre><code>(defun my_max (x y)  (if (&gt; x y) x y))</code></pre><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>递归计算列表的总和:</strong>  </p><pre><code>(defun total (x)  (if (null x)    0    (+ (first x) (total (rest x)))  ))(total &apos;(1 5 1))   =&gt;  7</code></pre><p>total 函数将列表当作单个的参数。第一个 if 语句在列表为空的情况下中断递归，返回零值。否则，该函数将第一个元素添加到列表其余部分的总和。现在应该明白如此构建 first 和 rest 的原因。first 能够去除列表的第一个元素，rest 简化了将尾部递归应用于列表其余部分的过程。</p><p><strong>递归计算列表的长度:</strong></p><pre><code>(defun len (x) (cond ((null x) 0) (t (+ (len (cdr x)) 1))))(len &apos;(a b c d)) =&gt; 4</code></pre><p>len用来计算一个表x的长（即元素个数）度<br>递归式是(len (cdr x)) ，终结条件是(null x)为真</p><p><strong>trace函数</strong><br>用来跟踪函数调用的情况</p><pre><code>(trace len)(len &apos;(a b c d)) =&gt;0: (LEN (A B C D))    1: (LEN (B C D))      2: (LEN (C D))        3: (LEN (D))          4: (LEN NIL)          4: LEN returned 0        3: LEN returned 1      2: LEN returned 2    1: LEN returned 30: LEN returned 4</code></pre><h2 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h2><p>7个基本操作符对应7大公理，任何其他函数都可以由其定义。也就是说，7个基本操作符包含了Lisp的所有语义。<br><strong>这7个基本操作符是：</strong></p><ol><li>Quote</li><li>Atom</li><li>Eq</li><li>Car</li><li>Cdr</li><li>Cons</li><li>Cond</li></ol><p>下面的函数系统Lisp都有提供，我们也可以用7个操作符函数重新实现一遍。</p><p><strong>NULL函数</strong><br>NULL函数用于检测表是否为空，或者元素是否为nil。  </p><pre><code>(defun null2 (x) (cond ((equal x nil) t) (t nil))))</code></pre><p>解释：如果参数与nil相等，就返回t，否则返回nil。这和逻辑学上的not函数是一致的（但null函数的应用范围更广，因为它可以应用于表）。</p><p><strong>And函数</strong></p><pre><code>(defun and2 (x y) (cond ((equal x nil) nil) ((not (equal y nil)) t) (t nil)))</code></pre><p><strong>Or函数</strong></p><pre><code>(defun or2 (x y) (cond ((equal x t) t) ((equal y t) t)))</code></pre><p><strong>Last 函数</strong></p><pre><code>(defun last2 (x) (cond ((equal (cdr x) nil) x) (t (last2 (cdr x)))))</code></pre><p><strong>Length函数</strong><br>下面讲如何计算一个表x的长（即元素个数）度。</p><pre><code>(defun len (x) (cond ((null x) 0) (t (+ (len (cdr x)) 1))))</code></pre><p>递归式是(len (cdr x)) ，终结条件是(null x)为真。</p><p><strong>Append函数</strong><br>设参数形式是x和y。很容易分析出来，递归式是(cons (car x) (append2 (cdr x) y))，终结条件是当x为NIL时，返回y。</p><pre><code>(defun append2 (x y) (cond ((eq x nil) y) (t (cons (car x) (append2 (cdr x) y)))))</code></pre><p><strong>Equal函数</strong><br>设参数形式是x和y。很容易分析出来，递归式是(equal (cdr x) (cdr y))，递归条件是(equal (car x) (car y))，终止条件是(equal (cdr x) nil)或者(equal (cdr y) nil)或者((atom x) (equal x y))</p><pre><code>(defun equal2 (x y)   (cond     ((null x) (not y))    ((null y) (not x))    ((atom x) (eq x y))    ((atom y) (eq x y))    ((not (equal2  (car x) (car y))) nil)    (t (equal2 (cdr x) (cdr y)))  ))</code></pre><p>代码解释：  </p><p><code>((null x) (not y))</code><br>首先，如果x为空，说明遇到了x列表的末尾，这时检测y列表是否也到了，如果到了（此时我们知道之前的元素都相等），那么返回真，否则返回假。  </p><p><code>((null y) (not x))</code>  </p><p>如果y到了末尾，一样处理。<br><code>((atom x) (eq x y))</code><br>如果x是一个原子，说明函数是从<code>(equal2 (car x) (car y))</code>字句进入的，且<code>(car x)</code>的结果为原子。这时函数就可以结束了，返回x=y的结果。<br><code>((atom y) (eq x y))</code><br>如果y是一个原子，说明函数是从<code>(equal2 (car x) (car y))</code>字句进入的，且<code>(car y)</code>的结果为原子。这时函数就可以结束了，返回x=y的结果。<br><code>(t (equal2 (cdr x) (cdr y)))</code><br>否则的情况，我们就递归。<br>总结，大家可以发现，其实这个函数的递归路径有两个。  </p><p><strong>If函数</strong><br>用cond可以实现if函数。实际上，在类c语言中，if语句强调的是程序的走向，但在Lisp中，程序的走向可以忽略（从某种意义上），而强调的是返回值。  </p><pre><code>(defun if2 (p e1 e2)(cond (p e1) (t e2)))</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code>#&apos;        组合符号  等价函数 function</code></pre><h1 id="Lisp开发Web程序"><a href="#Lisp开发Web程序" class="headerlink" title="Lisp开发Web程序"></a>Lisp开发Web程序</h1><p>用lisp可以开发出一套“子语言”，用于生成html。现成的成熟框架，可以参考cl-who。</p><p>可以把lisp代码编译成javascript。你用lisp编写的程序，到了html里，就成了javascript。可以看一下parenscript(<a href="http://www.cliki.net/parenscript" target="_blank" rel="noopener">http://www.cliki.net/parenscript</a>)  </p><p>cliki上搜一下web framework，你可以得到一大堆。你可以试一下cl-weblocks。阅读一下它的文档，你可以看到很多厉害的特性，忍不住会上手试一下！<a href="http://weblocks-framework.info" target="_blank" rel="noopener">http://weblocks-framework.info</a> 上面有不错的文档。有的文档资料可能旧了点，但能够说清楚。  </p><h2 id="使用Weblocks编写Web应用"><a href="#使用Weblocks编写Web应用" class="headerlink" title="使用Weblocks编写Web应用"></a>使用Weblocks编写Web应用</h2><p>安装weblocks</p><pre><code>(ql:quickload :weblocks)</code></pre><p>安装demo程序</p><pre><code>(ql:quickload :weblocks-demo)</code></pre><p>运行</p><pre><code>(weblocks:start-weblocks)    ;可以在8080端口启动一个http服务。</code></pre><p>运行示例</p><pre><code>(weblocks-demo:start-weblocks-demo :port 3455)</code></pre><p>访问：<a href="http://localhost:3455/weblocks-demo" target="_blank" rel="noopener">http://localhost:3455/weblocks-demo</a><br>(如果发现这样的报警，可以忽略，不影响：An instance of WEBLOCKS-DEMO with name weblocks-demo is already running, ignoring start request)  </p><p>创建自己的应用</p><pre><code>(wop:make-app &apos;NAME &quot;DIR&quot;)    ;建立名称为Name的应用，放在DIR目录下</code></pre><p>例如：(wop:make-app ‘firstapp “home/richard/lisp”)<br>这样就会在“home/richard/lisp”目录建立一个firstapp子目录，里面有几个必要的目录和模板程序。  </p><p>加载和修改自己的应用<br>要能在开发环境加载和修改自己的应用，需要能够找到firstapp。这需要了解一下asdf的配置。asdf是lisp的模块依赖的管理工具。具体可以参考：  </p><p><a href="http://www.common-lisp.net/project/asdf/" target="_blank" rel="noopener">http://www.common-lisp.net/project/asdf/</a><br><a href="http://basiccoder.com/constructing-common-lisp-package-by-asdf.html" target="_blank" rel="noopener">http://basiccoder.com/constructing-common-lisp-package-by-asdf.html</a><br><a href="http://blog.csdn.net/xiaojianpitt/article/details/7727152" target="_blank" rel="noopener">http://blog.csdn.net/xiaojianpitt/article/details/7727152</a>  </p><p>我的配置：<br>建立目录：/home/richard/.config/common-lisp/source-registry.conf.d<br>在里面建两个配置文件：<br>01practicals.conf<br>内容： (:tree “/home/richard/practicals-1.0.3/“)<br>这样就可以随时加载执行《实用commonlisp编程》里面的例子了。<br>比如：(ql:quickload :chapter31)就可以加载第31章的例子。<br>02richard.conf 指向我自己的工作目录。<br>内容：(:tree “/home/richard/lisp/“)。<br>这样就可以找到firstapp。用(ql:quickload :firstapp)来加载和修改。  </p><p>加载后，运行</p><pre><code>(in-package :firstapp)  切换到:firstapp包；(start-firstapp :port 3456)  启动应用，在3456端口监听</code></pre><p>学习资料推荐<br>Lisp的本质<br><a href="http://www.cnblogs.com/Leap-abead/articles/762180.html" target="_blank" rel="noopener">http://www.cnblogs.com/Leap-abead/articles/762180.html</a><br>Lisp之根源（The roots of Lisp）<br>中文版：<a href="http://daiyuwen.freeshell.org/gb/rol/roots_of_lisp.html" target="_blank" rel="noopener">http://daiyuwen.freeshell.org/gb/rol/roots_of_lisp.html</a><br>Lisp之美<br><a href="https://www.ibm.com/developerworks/cn/java/j-cb02067.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-cb02067.html</a><br>Common Lisp 初学者快速入门指导<br><a href="https://my.oschina.net/freeblues/blog/131557#1.2" target="_blank" rel="noopener">https://my.oschina.net/freeblues/blog/131557#1.2</a><br>在Mac下搭建Common Lisp开发环境(Emacs)<br><a href="http://it.taocms.org/06/954.htm" target="_blank" rel="noopener">http://it.taocms.org/06/954.htm</a>  </p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2017/12/10/lisp%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Elm学习指南</title>
      <link>http://qiansr.github.io/2017/09/10/Elm%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</link>
      <guid>http://qiansr.github.io/2017/09/10/Elm%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Sun, 10 Sep 2017 07:47:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Elm基础语法&quot;&gt;&lt;a href=&quot;#Elm基础语法&quot; class=&quot;headerlink&quot; title=&quot;Elm基础语法&quot;&gt;&lt;/a&gt;Elm基础语法&lt;/h1&gt;&lt;h2 id=&quot;常用数据结构&quot;&gt;&lt;a href=&quot;#常用数据结构&quot; class=&quot;headerlink&quot; 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Elm基础语法"><a href="#Elm基础语法" class="headerlink" title="Elm基础语法"></a>Elm基础语法</h1><h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><p>列表List    ： 只能容纳单一类型元素,是类型的容器而不是类型，List String才是类型<br>元祖Tuples：可为不同类型，固定长度小于10<br>Records    ：  具有键值对的数据结构</p><h3 id="List-（列表）"><a href="#List-（列表）" class="headerlink" title="List （列表）"></a>List （列表）</h3><pre><code>list 方法List.drop 1 [1,2,3,4]   —  [1,2,3]List.length [1,2,3,4]   — 4List.head [1,2,3,4]      — Just 1 : Maybe.Maybe numberList.tail [1,2,3,4]     — Just [2,3,4] : Maybe.Maybe (List number)List.reverse [1,2,3,4]    — [4,3,2,1] : List number           反序List.sort [1,4,3,2]    — [1,2,3,4] : List number           排序 List.maximum a        — Just 4 : Maybe.Maybe number    最大值List.minimum a        — Just 1 : Maybe.Maybe number    最小值    0::[1,2,3,4]         — [0,1,2,3,4] : List number        “::”向列表添加元素0 [-1,-2]++[0,1,2,3,4]    — [-1,-2,0,1,2,3,4] : List number      “++”拼接列表</code></pre><h3 id="tuples-（元组）"><a href="#tuples-（元组）" class="headerlink" title="tuples （元组）"></a>tuples （元组）</h3><h3 id="records-（记录）"><a href="#records-（记录）" class="headerlink" title="records  （记录）"></a>records  （记录）</h3><pre><code>point = { x = 3, y = 4 }                -- create a recordpoint.x                                 -- 访问字段List.map .x [point,{x=0,y=0}]           -- field access function{ point | x = 6 }                            -- update 字段{ point | x = point.x + 1, y = point.y + 1}  -- update 多个字段dist {x,y} = sqrt (x^2 + y^2)                -- pattern matching on fieldstype alias Location =    { line : Int , column : Int}    -- type aliases for records{x=3,y=7}.x  or .y {x=3,y=7} ／／.y为一个函数bill = {name = “cyq”, age = 20}bill2 = {bill | name = “222”}      copy一份bill — { name = “222”, age = 20 } : { age : number, name : String }</code></pre><ul><li>你不可以使用不存在的field.</li><li>field不可為 undefined 或是 null.</li><li>你不可以使用 this 或 self 等關鍵字來創造遞迴的 records</li></ul><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>有点类似es6的desttructuring</p><h2 id="中缀运算符-（可自定义）"><a href="#中缀运算符-（可自定义）" class="headerlink" title="中缀运算符 （可自定义）"></a>中缀运算符 （可自定义）</h2><p>您可以创建自定义中缀运算符。 优先级从0到9，其中9是最紧密的。默认优先级为9，默认 关联性为左。您可以自行设置，但不能覆盖内置运算符。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><pre><code>module MyModule exposing (..)-- qualified importsimport List                    -- List.map, List.foldlimport List as L               -- L.map, L.foldl-- open importsimport List exposing (..)               -- map, foldl, concat, ...import List exposing ( map, foldl )     -- map, foldl</code></pre><p>优先进口合格。模块名称必须与其文件名匹配，因此模块Parser.Utils需要在文件中Parser/Utils.elm。</p><h2 id="类型注释"><a href="#类型注释" class="headerlink" title="类型注释"></a>类型注释</h2><p>一些常见的类型：Int，Float，String，Bool</p><h2 id="型別別名-type-alias"><a href="#型別別名-type-alias" class="headerlink" title="型別別名 (type alias)"></a>型別別名 (type alias)</h2><p>有時候，單純的基本型別可能無法完全詮釋我們想要表達的意思，也有可能是資料結構太複雜，我們想用一個簡單的名稱稱呼它，這時型別別名就可派上用場。</p><pre><code>type alias Name = Stringtype alias Age = Inttype alias Person =    { name: String    , age: Int    }createPerson: Name -&gt; Age -&gt; PersoncreatePerson name age =    { name = name    , age = age    }</code></pre><p><code>type alias Name = String</code> 的意思可以翻譯為 將 Name 設定為 String 的另一個別名。如此一來，我們就可以像這樣定義:<br><code>createPerson: Name -&gt; Age -&gt; Person</code><br>而不是<br><code>createPerson: String -&gt; Int -&gt; Person</code></p><h3 id="自定义类型：（建立自創型別與-Union-Type）"><a href="#自定义类型：（建立自創型別與-Union-Type）" class="headerlink" title="自定义类型：（建立自創型別與 Union Type）"></a>自定义类型：（建立自創型別與 Union Type）</h3><p>自創型別的方法如下：<br><code>type Directions = Up | Down | Left | Right</code><br><code>type Maybe a = Nothing | Just a</code><br>我們可以創造兩種不同款式的型別，第一種像是上例的 Directions 比較直觀簡單，在這型別下只會有四種可能的值，就是我們定義的 Up，Down，Left，Right。在使用上的話我們可以這麼做：</p><pre><code>convertDirectionsToInt: Directions -&gt; IntconvertDirectionsToInt dir =    case dir of        Up -&gt; 1        Down -&gt; 2        Left -&gt; 3        Right -&gt; 4convertDirectionsToInt Up -- 1</code></pre><h2 id="Union-Types"><a href="#Union-Types" class="headerlink" title="Union Types"></a>Union Types</h2><p>用来表示一组可能的值，每个值叫做一个Tag<br>指的是我們可以將其它已存在的型別組合進我們自創的型別中。範例中我們建立了一個叫 Maybe 的型別，後面跟著的 a 是所謂的 型別變數，再更後面則是型別的值。我們可以自由在型別變數中帶入其他的型別如下：</p><pre><code>-- 把 String 帶入 amaybeString: Maybe StringmaybeString = Just &quot;I am a string&quot;-- 把 Int 帶入 amaybeInt: Maybe IntmaybeInt = Just 1anotherMaybeInt: Maybe IntmaybeInt = Nothing</code></pre><p>以上三個變數都是屬於 Maybe a 型別，但隨著帶入的 a 不同，型別裡的值也會跟著改變。當然你也可以建立更複雜的 Union Type，例如:<br><code>type Directions a b = Up a | Down b | Left a b | Right</code></p><h2 id="javascript-互操作"><a href="#javascript-互操作" class="headerlink" title="javascript 互操作"></a>javascript 互操作</h2><ol><li>在HTML中嵌入Elm，</li><li>在Elm和JavaScript之间来回发送消息</li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>multiply a b = a*bdouble = multiply 2List.map double [1,2,3,4]-- 通过匿名函数形式。List.map (\a -&gt; a * 2) [1..4] -- [2, 4, 6, 8]</code></pre><p><code>\counterMsg -&gt; Modify id counterMsg</code>是Elm中的匿名函数，在Elm中，匿名函数使用\开头紧接着参数，<br>并在-&gt;后书写返回值表达式，形如<code>\a -&gt; b</code>。</p><p>– 通过<code>let...in...</code>语句来定义来定义一些将要立即使用的值。</p><pre><code>volume {width, height, depth} = let area = width * height in area * depthvolume { width = 3, height = 2, depth = 7 } -- 42</code></pre><p>函数名  参数 = </p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>if true then “WHOA” else if true then “n” else “0”</p><pre><code>case alist of[]-&gt;””[x]-&gt;””x::xs-&gt;””</code></pre><h1 id="elm-工程化"><a href="#elm-工程化" class="headerlink" title="elm 工程化"></a>elm 工程化</h1><pre><code>elm-webpack-project 脚手架git clone https://github.com/moarwick/elm-webpack-starter rm -rf .git        git init   git add .   git commit -m &apos;first commit&apos;npm run reinstall  安装依赖</code></pre><p>自己搭建</p><pre><code>－－－－package.json &quot;scripts&quot;: {    &quot;elm-install&quot;: &quot;elm-package install&quot;,    &quot;build&quot;: &quot;elm-make Main.elm --output=build/index.js&quot;,    &quot;start&quot;: &quot;elm-live Main.elm --output=build/index.js --open&quot;   },  &quot;devDependencies&quot;: {    &quot;elm&quot;: &quot;^0.18.0&quot;,    &quot;elm-live&quot;: &quot;^2.7.4&quot; //热更新，热加载模块  }－－－－－elm-package.json &quot;dependencies&quot;: {        &quot;elm-lang/core&quot;: &quot;5.0.0 &lt;= v &lt; 6.0.0&quot;,        &quot;elm-lang/html&quot;: &quot;2.0.0 &lt;= v &lt; 3.0.0&quot;,        &quot;elm-lang/http&quot;: &quot;1.0.0 &lt;= v &lt; 2.0.0&quot;,        &quot;evancz/elm-markdown&quot;: &quot;3.0.1 &lt;= v &lt; 4.0.0&quot;  },  &quot;elm-version&quot;: &quot;0.18.0 &lt;= v &lt; 0.19.0&quot;－－－－－－－index.html&lt;div id=“main”&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;      var node = document.getElementById(‘main’);      var app = Elm.Main.embed(node); &lt;/script&gt;－－－－－npm inpm run elm-installnpm run start</code></pre><h1 id="官网示例库"><a href="#官网示例库" class="headerlink" title="官网示例库"></a>官网示例库</h1><p>git clone <a href="https://github.com/evancz/elm-architecture-tutorial.git" target="_blank" rel="noopener">https://github.com/evancz/elm-architecture-tutorial.git</a><br>cd elm-architecture-tutorial</p><p><strong>学习资源</strong><br>Elm入门实践系列<br><a href="https://segmentfault.com/a/1190000005701562" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005701562</a><br>初识Elm语言你只需要Y分钟<br><a href="https://github.com/Jocs/jocs.github.io/issues/2" target="_blank" rel="noopener">https://github.com/Jocs/jocs.github.io/issues/2</a><br>Elm架构教程<br><a href="https://segmentfault.com/a/1190000004872909" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004872909</a>  </p>]]></content:encoded>
      
      <comments>http://qiansr.github.io/2017/09/10/Elm%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
